
<html>
<head>

<title>Karel Reader</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/> 
<script src="../../plugins/jquery.min.js"></script>
<link href="../../plugins/bootstrap/css/bootstrap.min.css" rel="stylesheet"/> 
<script src="../../plugins/bootstrap/js/bootstrap.min.js"></script>
<link href="../../style.css" rel="stylesheet"/> 
<script src="../..//karel/js/html/websiteImports.js"></script>
<script>importCss();</script>
<script>importJs();</script>
</head>
<body>
<!-- container -->
<div class="bookContainer">

<!-- side bar -->
<div class="bookSideBar">
<div class="homeLink">
 <a href="../../java/fr/intro.html">
<span aria-hidden="true" class="glyphicon glyphicon-home"></span> 
      Karel
    </a> 
</div>
<hr/>
<div class="chapterTab" onclick="location.href='../../java/fr/chapter1.html'">
<a class="bookLink btn btn-link" href="../../java/fr/chapter1.html">
      1 - Rencontrez Karel
    </a> 
</div>
<div class="chapterTab" onclick="location.href='../../java/fr/chapter2.html'">
<a class="bookLink btn btn-link" href="../../java/fr/chapter2.html">2 - Programmation</a> 
</div>
<div class="chapterTab" onclick="location.href='../../java/fr/chapter3.html'">
<a class="bookLink btn btn-link" href="../../java/fr/chapter3.html">3 - Nouvelles méthodes</a> 
</div>
<div class="chapterTab" onclick="location.href='../../java/fr/chapter4.html'">
<a class="bookLink btn btn-link" href="../../java/fr/chapter4.html">4 - Décomposition</a> 
</div>
<div class="chapterTab" onclick="location.href='../../java/fr/chapter5.html'">
<a class="bookLink btn btn-link" href="../../java/fr/chapter5.html">5 - Boucles For</a> 
</div>
<div class="chapterTab" onclick="location.href='../../java/fr/chapter6.html'">
<a class="bookLink btn btn-link" href="../../java/fr/chapter6.html">6 - Boucles While</a> 
</div>
<div class="chapterTab" onclick="location.href='../../java/fr/chapter7.html'">
<a class="bookLink btn btn-link" href="../../java/fr/chapter7.html">7 - Conditions</a> 
</div>
<div class="chapterTab" onclick="location.href='../../java/fr/chapter8.html'">
<a class="bookLink btn btn-link" href="../../java/fr/chapter8.html">8 - Raffinement</a> 
</div>
<div class="chapterTab" onclick="location.href='../../java/fr/chapter9.html'">
<a class="bookLink btn btn-link" href="../../java/fr/chapter9.html">9 - SuperKarel</a> 
</div>
<div class="chapterTab" onclick="location.href='../../java/fr/reference.html'">
<a class="bookLink btn btn-link" href="../../java/fr/reference.html">10 - Référence</a> 
</div>
<div class="chapterTab" onclick="location.href='../../java/fr/ide.html'">
<a class="bookLink btn btn-link" href="../../java/fr/ide.html">11 - Code</a> 
</div>
<hr/>
 <a href="../../"><img src="../../images/unFlag.png" style="width:40px"/> Apprendre encore plus</a> 
<!-- <center>
    <img style ="width:75px;" src="../../images/stanford.png"/> 
    </center> -->
</div>
<!-- content -->
<div class="bookContent" style="display: flex;">
<!-- right gutter -->
<div style="flex-grow:1;max-width:50px;"></div>
<!-- main stuff -->
<div class="" style="flex-basis:740px; max-width:740px; margin-left:20px; margin-right:20px">
<div class="row">
<div class="col-md-12 col-xs-12">


<h1>Chapitre 6: Boucles While</h1>
<hr/>
<p>La technique boucle for définir de nouvelles méthodes et à définir les boucle for si utiles qu’ils soient, ne permet pas à Karel de résoudre de nouveaux problèmes. Chaque fois que vous run un programme , il fait toujours exactement la même chose. Les programmes deviennent beaucoup plus utiles lorsqu'ils peuvent répondre différemment à différentes entrées.</p>
<p>Par exemple. Disons que vous vouliez écrire un programme pour avoir Karel avancer contre un mur. Mais vous ne voulez pas simplement que ce programme fonctionne sur un monde avec une taille fixe. Vous voudriez écrire un programme unique qui pourrait fonctionner sur n'importe quel monde.</p>





<div class="section embeddedIde" id="moveToWall">
<div class="ide getStarted" id="moveToWallIde" style="height:352.0px">
<div class="ideCenter" id="moveToWallIdeCenter">
<div class="ideEditorDiv" id="moveToWallEditorDiv" style="width:200px"></div>
<div class="ideCanvasDiv" id="moveToWallCanvasDiv">
<div class="worldDropdown">
<div class="dropdown">
<button aria-expanded="true" aria-haspopup="true" class="btn btn-default dropdown-toggle" data-toggle="dropdown" id="dropdownMenu1" type="button">Changer le monde<span class="caret"></span>
</button>
<ul aria-labelledby="dropdownMenu1" class="dropdown-menu" id="moveToWallWorlds">
<li><a>1x1</a> </li>
<li><a>4x4</a> </li>
<li><a>3x6</a> </li>
<li><a>7x7</a> </li>
<li><a>8x8</a> </li>
</ul>
</div>
</div>
<canvas class="ideCanvas" id="moveToWallCanvas"></canvas>
</div>
</div>
</div>
<div style="width:100%;">
<div class="buttonBar">
<button class="btn btn-default" id="moveToWallRunButton"><span class="glyphicon glyphicon-play"></span>Exécuter de programme</button>
</div>
</div>
<script>

        

function examplemoveToWall() {
STARTER_CODE = `

/*
 * Fichier: AvancerAuMur.java
 * --------------------------
 * Utilise une boucle "while" de avancer Karel jusqu'
 * à ce qu'elle heurte un mur. Fonctionne sur n'impor
 * te quel monde de taille.
 */
import stanford.karel.*;
public class AvancerAuMur extends Karel {
   public void run() {
      avancerAuMur();
   }

   /* c'est une méthode très utile */
   private void avancerAuMur() {
      while(devantDegage()) {
         avancer();
      }
   } 
}
`
// because of that extra endline at the start of the string
STARTER_CODE = STARTER_CODE.trim();

 var karelIde = null;
 var karelEditor = null;
 var buttonState = 'play';

 function main() {
   karelEditor = importEditorCode('moveToWallEditor','moveToWallEditorDiv', STARTER_CODE, false);
    setupWorldDropdown();
    
    
    var canvas = document.getElementById('moveToWallCanvas');
    karelIde = KarelIde('java',karelEditor, canvas, '7x7', 0.0, 'fr');
    $('#moveToWallRunButton').click(function(){playClicked()});
    onresize();
    
 }

 function setupWorldDropdown() {
    console.log('setup world dropdown')
    let ul = document.getElementById('moveToWallWorlds')
    
    if (!ul.childNodes || ul.childNodes.length == 0) return;

    // Iterate LIs
    for (var itemi=0;itemi<ul.childNodes.length;itemi++) {
        var li = ul.childNodes[itemi];
        if(li.nodeName == "LI") {
          var a = li.childNodes[0]
          let worldName = a.innerHTML;
          console.log(worldName)
          a.onclick = () => setWorld(worldName);

        }
    }
 }

 function setWorld(worldName){
    console.log('here we go', worldName)
    karelIde.changeWorld(worldName)
    changeToPlayButton()
 }

 function playClicked() {
  if(buttonState == 'play') {
    karelIde.playButton();
    changeToResetButton();
   } else if (buttonState == 'reset') {
    karelIde.stopButton();
    changeToPlayButton();
   }
  }

  function changeToPlayButton() {
    var playText = '<span class="glyphicon glyphicon-play"></span> Run Program';
    $('#moveToWallRunButton').html(playText);
    buttonState = 'play';
  }

  function changeToResetButton() {
    var resetText = '<span class="glyphicon glyphicon-repeat"></span> Reset Program';
    $('#moveToWallRunButton').html(resetText);
    buttonState = 'reset';  
  }

 function onresize() { 
    var parentHeight = 352.0;
    var canvasWidth = 300
    var parentWidth = $("#moveToWall").width();
    console.log('pw: ' + parentWidth);

    var ide = document.getElementById('moveToWallIde');
    var editorDiv = document.getElementById('moveToWallEditorDiv');
    var canvas = document.getElementById('moveToWallCanvasDiv');
    
    var ideHeight = parentHeight
    var centerHeight = ideHeight;

    var availibleWidth = parentWidth;
    var elementSpacing = 12;

    var editorWidth = availibleWidth - canvasWidth - elementSpacing; 

    canvas.style.width = canvasWidth + 'px';
    canvas.style.height = canvasWidth + 'px';
    canvas.style.left = (editorWidth + elementSpacing) + 'px';



    editorDiv.style.left = 0 + 'px'
    editorDiv.style.width = editorWidth + 'px';
    editorDiv.style.height = parentHeight + 'px';
    console.log('editor width: ' + editorWidth)

    if (karelEditor) {
       karelEditor.renderer.onResize();
    }
 }
 main()
 
}
examplemoveToWall();
    </script>
</div>

<p>Essayez de changer le monde en cliquant sur le menu déroulant "Changer le monde" situé au-dessus du monde. Pour tous les avancer , Karel avancer jusqu’à ce qu’il heurte un mur. Notez que cet exploit ne peut pas être accompli en utilisant un <code class="keyword">for</code>  boucle. Cela nous obligerait à connaître la taille du monde au moment de la programmation.
</p>
<h3>Boucle While normale</h3>
<p>À Karel, un <code class="keyword">while</code>  la boucle est utilisée pour répéter un corps de code<i>aussi longtemps que</i>une condition donnée est valable. Le boucle while a la forme générale suivante:</p>
<p class="demoCode">
 <code><span class="keyword">while</span>(</code> <i class="demoText">tester</i> <code>){</code> <br/>
<i class="demoText" style="margin-left:2em">déclarations à répéter</i><br/>
 <code>}</code> 
</p>
<p>Le flux de contrôle d'un boucle while est le suivant. Lorsque le programme frappe un boucle while il commence à répéter un processus où il commence<i>chèques</i> si le test réussit, et si oui<i>run s</i> le code dans le corps.
</p>
Quand le programme<i>chèques</i> si le test réussit, il décide si le<i class="demoText">tester</i>est vrai pour l'état actuel du monde. Si c'est le cas, la boucle run le code dans le corps. Si le test échoue, la boucle est terminée et le programme avancer est avancer .
<p>
Quand le programme<i>run s</i>le corps de la boucle, le programme exécute les lignes dans le corps une par une. Lorsque le programme arrive à la fin du boucle while , il retourne au début de la boucle. Il revérifie ensuite le test et continue à boucler s'il réussit. Le programme ne quitte pas la boucle tant qu'il n'a pas été vérifié et que le test échoue.</p>
<p>
Karel a beaucoup<i class="demoText">tester</i> déclarations, et nous les passerons toutes en revue dans le chapitre suivant. Pour l'instant, nous allons utiliser une seule déclaration de test: <code>devantDegage()</code>  ce qui est vrai s'il n'y a pas de mur directement devant Karel.
</p>
<h3>Bug de poteau de clôture</h3>
<p>Modifions notre programme ci-dessus pour le rendre plus intéressant. Au lieu de simplement vous déplacer contre un mur, jetons Karel de placer une ligne de jetons , une dans chaque carré. Encore une fois, nous voulons que ce programme fonctionne pour un monde de toute taille:</p>





<div class="section embeddedIde" id="beeperLineBug1">
<div class="ide getStarted" id="beeperLineBug1Ide" style="height:369.6px">
<div class="ideCenter" id="beeperLineBug1IdeCenter">
<div class="ideEditorDiv" id="beeperLineBug1EditorDiv" style="width:200px"></div>
<div class="ideCanvasDiv" id="beeperLineBug1CanvasDiv">
<div class="worldDropdown">
<div class="dropdown">
<button aria-expanded="true" aria-haspopup="true" class="btn btn-default dropdown-toggle" data-toggle="dropdown" id="dropdownMenu1" type="button">Changer le monde<span class="caret"></span>
</button>
<ul aria-labelledby="dropdownMenu1" class="dropdown-menu" id="beeperLineBug1Worlds">
<li><a>1x1</a> </li>
<li><a>4x4</a> </li>
<li><a>3x6</a> </li>
<li><a>7x7</a> </li>
<li><a>8x8</a> </li>
</ul>
</div>
</div>
<canvas class="ideCanvas" id="beeperLineBug1Canvas"></canvas>
</div>
</div>
</div>
<div style="width:100%;">
<div class="buttonBar">
<button class="btn btn-default" id="beeperLineBug1RunButton"><span class="glyphicon glyphicon-play"></span>Exécuter de programme</button>
</div>
</div>
<script>

        

function examplebeeperLineBug1() {
STARTER_CODE = `

/*
 * Fichier: JetonLigneJeton.java
 * ----------------------------
 * Utilise un boucle while pour placer une ligne de j
 * etons . Ce programme fonctionne pour un monde de t
 * oute taille. Cependant, comme chaque monde nécessi
 * te avancer moins que laisserJeton il manque toujou
 * rs un jeton .
 */
import stanford.karel.*;
public class JetonLigneJeton extends Karel {
   public void run() {
   	  /* répète jusqu'à ce que Karel soit face à un mur */
      while(devantDegage()) {
      	 /* placer un jeton sur le carré actuel */ 
         laisserJeton();
      	 /* avancer à la prochaine case */
         avancer();
      }
   }
}
`
// because of that extra endline at the start of the string
STARTER_CODE = STARTER_CODE.trim();

 var karelIde = null;
 var karelEditor = null;
 var buttonState = 'play';

 function main() {
   karelEditor = importEditorCode('beeperLineBug1Editor','beeperLineBug1EditorDiv', STARTER_CODE, true);
    setupWorldDropdown();
    
    
    var canvas = document.getElementById('beeperLineBug1Canvas');
    karelIde = KarelIde('java',karelEditor, canvas, '7x7', 0.0, 'fr');
    $('#beeperLineBug1RunButton').click(function(){playClicked()});
    onresize();
    
 }

 function setupWorldDropdown() {
    console.log('setup world dropdown')
    let ul = document.getElementById('beeperLineBug1Worlds')
    
    if (!ul.childNodes || ul.childNodes.length == 0) return;

    // Iterate LIs
    for (var itemi=0;itemi<ul.childNodes.length;itemi++) {
        var li = ul.childNodes[itemi];
        if(li.nodeName == "LI") {
          var a = li.childNodes[0]
          let worldName = a.innerHTML;
          console.log(worldName)
          a.onclick = () => setWorld(worldName);

        }
    }
 }

 function setWorld(worldName){
    console.log('here we go', worldName)
    karelIde.changeWorld(worldName)
    changeToPlayButton()
 }

 function playClicked() {
  if(buttonState == 'play') {
    karelIde.playButton();
    changeToResetButton();
   } else if (buttonState == 'reset') {
    karelIde.stopButton();
    changeToPlayButton();
   }
  }

  function changeToPlayButton() {
    var playText = '<span class="glyphicon glyphicon-play"></span> Run Program';
    $('#beeperLineBug1RunButton').html(playText);
    buttonState = 'play';
  }

  function changeToResetButton() {
    var resetText = '<span class="glyphicon glyphicon-repeat"></span> Reset Program';
    $('#beeperLineBug1RunButton').html(resetText);
    buttonState = 'reset';  
  }

 function onresize() { 
    var parentHeight = 369.6;
    var canvasWidth = 300
    var parentWidth = $("#beeperLineBug1").width();
    console.log('pw: ' + parentWidth);

    var ide = document.getElementById('beeperLineBug1Ide');
    var editorDiv = document.getElementById('beeperLineBug1EditorDiv');
    var canvas = document.getElementById('beeperLineBug1CanvasDiv');
    
    var ideHeight = parentHeight
    var centerHeight = ideHeight;

    var availibleWidth = parentWidth;
    var elementSpacing = 12;

    var editorWidth = availibleWidth - canvasWidth - elementSpacing; 

    canvas.style.width = canvasWidth + 'px';
    canvas.style.height = canvasWidth + 'px';
    canvas.style.left = (editorWidth + elementSpacing) + 'px';



    editorDiv.style.left = 0 + 'px'
    editorDiv.style.width = editorWidth + 'px';
    editorDiv.style.height = parentHeight + 'px';
    console.log('editor width: ' + editorWidth)

    if (karelEditor) {
       karelEditor.renderer.onResize();
    }
 }
 main()
 
}
examplebeeperLineBug1();
    </script>
</div>

<p>Ça a l'air génial. Sauf pour un problème. Sur tous les jeton Karel ne place pas un jeton sur le dernier carré de la ligne (regarde de près). Lorsque Karel est sur la dernière case, le programme n'exécute pas le corps de la boucle car le test ne réussit plus. Karel fait face à un mur. Vous pourriez être tenté d'essayer de changer l'ordre du corps afin que Karel avancer s avant de placer une abeille. Le code est éditable alors allez l'essayer!</p>
<p>Il y a un problème plus profond qu'aucun réarrangement du corps ne peut résoudre. Pour le monde avec 7 colonnes, Karel doit mettre 7 jetons , mais devrait seulement avancer 6 fois. Etant donné que le boucle while exécute les deux lignes lorsqu'un test est réussi, comment pouvez-vous boucle while le programme à exécuter une commande une fois de plus que l'autre?</p>
<p>
Le bogue de ce programme est un exemple de problème de programmation appelé <b>erreur de poteau de clôture</b> . Le nom vient du fait que si vous souhaitez construire une clôture composée de panneaux qui ont un poteau de clôture de chaque taille, le nombre de poteaux de clôture est toujours supérieur au nombre de panneaux. Combien de poteaux de clôture, par exemple, avez-vous besoin de construire une clôture de 10 panneaux? La réponse est 11, comme illustré par le diagramme suivant:
</p>
<center>
<img src="../../images/ch6/fencepost.png" style="width:500px;margin-bottom:10px"/> 
</center>
<p>Une fois que vous l'avez découvert, la résolution de ce bogue est en fait assez facile. Avant que Karel ne s’arrête au bout du monde, tout ce que le programme doit faire est de placer un dernier jeton :</p>





<div class="section embeddedIde" id="beeperLine">
<div class="ide getStarted" id="beeperLineIde" style="height:369.6px">
<div class="ideCenter" id="beeperLineIdeCenter">
<div class="ideEditorDiv" id="beeperLineEditorDiv" style="width:200px"></div>
<div class="ideCanvasDiv" id="beeperLineCanvasDiv">
<div class="worldDropdown">
<div class="dropdown">
<button aria-expanded="true" aria-haspopup="true" class="btn btn-default dropdown-toggle" data-toggle="dropdown" id="dropdownMenu1" type="button">Changer le monde<span class="caret"></span>
</button>
<ul aria-labelledby="dropdownMenu1" class="dropdown-menu" id="beeperLineWorlds">
<li><a>1x1</a> </li>
<li><a>4x4</a> </li>
<li><a>3x6</a> </li>
<li><a>7x7</a> </li>
<li><a>8x8</a> </li>
</ul>
</div>
</div>
<canvas class="ideCanvas" id="beeperLineCanvas"></canvas>
</div>
</div>
</div>
<div style="width:100%;">
<div class="buttonBar">
<button class="btn btn-default" id="beeperLineRunButton"><span class="glyphicon glyphicon-play"></span>Exécuter de programme</button>
</div>
</div>
<script>

        

function examplebeeperLine() {
STARTER_CODE = `

/*
 * Fichier: LigneJeton.java
 * ------------------------
 * Utilise une boucle "while" pour placer une ligne d
 * e jetons . Ce programme fonctionne pour un monde d
 * e toute taille.
 */
import stanford.karel.*;
public class LigneJeton extends Karel {
   public void run() {
      /* répète jusqu'à ce que Karel soit face à un mur */
      while(devantDegage()) {
         /* placer un jeton sur le carré actuel */ 
         laisserJeton();
         /* avancer à la prochaine case */
         avancer();
      }
      /* résout le bogue de clôture */
      laisserJeton();
   }
}
`
// because of that extra endline at the start of the string
STARTER_CODE = STARTER_CODE.trim();

 var karelIde = null;
 var karelEditor = null;
 var buttonState = 'play';

 function main() {
   karelEditor = importEditorCode('beeperLineEditor','beeperLineEditorDiv', STARTER_CODE, true);
    setupWorldDropdown();
    
    
    var canvas = document.getElementById('beeperLineCanvas');
    karelIde = KarelIde('java',karelEditor, canvas, '7x7', 0.8, 'fr');
    $('#beeperLineRunButton').click(function(){playClicked()});
    onresize();
    
 }

 function setupWorldDropdown() {
    console.log('setup world dropdown')
    let ul = document.getElementById('beeperLineWorlds')
    
    if (!ul.childNodes || ul.childNodes.length == 0) return;

    // Iterate LIs
    for (var itemi=0;itemi<ul.childNodes.length;itemi++) {
        var li = ul.childNodes[itemi];
        if(li.nodeName == "LI") {
          var a = li.childNodes[0]
          let worldName = a.innerHTML;
          console.log(worldName)
          a.onclick = () => setWorld(worldName);

        }
    }
 }

 function setWorld(worldName){
    console.log('here we go', worldName)
    karelIde.changeWorld(worldName)
    changeToPlayButton()
 }

 function playClicked() {
  if(buttonState == 'play') {
    karelIde.playButton();
    changeToResetButton();
   } else if (buttonState == 'reset') {
    karelIde.stopButton();
    changeToPlayButton();
   }
  }

  function changeToPlayButton() {
    var playText = '<span class="glyphicon glyphicon-play"></span> Run Program';
    $('#beeperLineRunButton').html(playText);
    buttonState = 'play';
  }

  function changeToResetButton() {
    var resetText = '<span class="glyphicon glyphicon-repeat"></span> Reset Program';
    $('#beeperLineRunButton').html(resetText);
    buttonState = 'reset';  
  }

 function onresize() { 
    var parentHeight = 369.6;
    var canvasWidth = 300
    var parentWidth = $("#beeperLine").width();
    console.log('pw: ' + parentWidth);

    var ide = document.getElementById('beeperLineIde');
    var editorDiv = document.getElementById('beeperLineEditorDiv');
    var canvas = document.getElementById('beeperLineCanvasDiv');
    
    var ideHeight = parentHeight
    var centerHeight = ideHeight;

    var availibleWidth = parentWidth;
    var elementSpacing = 12;

    var editorWidth = availibleWidth - canvasWidth - elementSpacing; 

    canvas.style.width = canvasWidth + 'px';
    canvas.style.height = canvasWidth + 'px';
    canvas.style.left = (editorWidth + elementSpacing) + 'px';



    editorDiv.style.left = 0 + 'px'
    editorDiv.style.width = editorWidth + 'px';
    editorDiv.style.height = parentHeight + 'px';
    console.log('editor width: ' + editorWidth)

    if (karelEditor) {
       karelEditor.renderer.onResize();
    }
 }
 main()
 
}
examplebeeperLine();
    </script>
</div><hr/>
<center>
<a class="btn btn-primary btn-lg" href="chapter7.html" role="button">Chapitre suivant</a> 
</center>




<div style="height:60px"></div>
</div>
</div>
</div>
<!-- right gutter -->
<div style="flex-grow:4"></div>
</div>
</div>
</body>
</html>
