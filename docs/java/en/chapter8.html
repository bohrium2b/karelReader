

<html> 
<head> 
<title>Karel Reader</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<script src="../../plugins/jquery.min.js"></script>

<link rel="stylesheet"  href="../../plugins/bootstrap/css/bootstrap.min.css">
<script src="../../plugins/bootstrap/js/bootstrap.min.js"></script>

<link rel="stylesheet" href="../../style.css">

<script src="../..//karel/js/html/websiteImports.js"></script>
<script>importCss();</script>
<script>importJs();</script>
</head> 
<body>
  <!-- container -->
  <div class="bookContainer">
<!-- side bar -->
<div class="bookSideBar">
  <div class="homeLink">
    <a href="../../java/en/intro.html">
      <span class="glyphicon glyphicon-home" aria-hidden="true"></span>
      Karel
    </a>
  </div>
  <hr/>
  
  <div class="chapterTab" onclick="location.href='../../java/en/chapter1.html'">
    <a class="bookLink btn btn-link" href="../../java/en/chapter1.html">
      1 - Meet Karel
    </a>
  </div>
  <div class="chapterTab" onclick="location.href='../../java/en/chapter2.html'">
    <a class="bookLink btn btn-link" href="../../java/en/chapter2.html">2 - Programming</a>
  </div>
  <div class="chapterTab" onclick="location.href='../../java/en/chapter3.html'">
    <a class="bookLink btn btn-link" href="../../java/en/chapter3.html">3 - New Methods</a>
  </div>
  <div class="chapterTab" onclick="location.href='../../java/en/chapter4.html'">
    <a class="bookLink btn btn-link" href="../../java/en/chapter4.html">4 - Decomposition</a>
  </div>
  <div class="chapterTab" onclick="location.href='../../java/en/chapter5.html'">
    <a class="bookLink btn btn-link" href="../../java/en/chapter5.html">5 - For Loops</a>
  </div>
  <div class="chapterTab" onclick="location.href='../../java/en/chapter6.html'">
    <a class="bookLink btn btn-link" href="../../java/en/chapter6.html">6 - While Loops</a>
  </div>
  <div class="chapterTab" onclick="location.href='../../java/en/chapter7.html'">
    <a class="bookLink btn btn-link" href="../../java/en/chapter7.html">7 - Conditionals</a>
  </div>
  <div class="chapterTab" onclick="location.href='../../java/en/chapter8.html'">
    <a class="bookLink btn btn-link" href="../../java/en/chapter8.html">8 - Refinement</a>
  </div>
  <div class="chapterTab" onclick="location.href='../../java/en/chapter9.html'">
    <a class="bookLink btn btn-link" href="../../java/en/chapter9.html">9 - SuperKarel</a>
  </div>

  <div class="chapterTab" onclick="location.href='../../java/en/reference.html'">
    <a class="bookLink btn btn-link" href="../../java/en/reference.html">10 - Reference</a>
  </div>

  <div class="chapterTab" onclick="location.href='../../java/en/ide.html'">
    <a class="bookLink btn btn-link" href="../../java/en/ide.html">11 - Code</a>
  </div>

  <hr/>

  <a href="../../"><img style = "width:40px" src="../../images/unFlag.png"/> Learn more</a> 

  <!-- <center>
    <img style ="width:75px;" src="../../images/stanford.png"/>
    </center> -->
</div>
    <!-- content -->
    <div class="bookContent" style="display: flex;">
      <!-- right gutter -->
      <div style="flex-grow:1;max-width:50px;"></div>

      <!-- main stuff -->
      <div class="" style="flex-basis:740px; max-width:740px; margin-left:20px; margin-right:20px">
      <div class="row">
        <div class="col-md-12 col-xs-12">

<h1>Chapter 8: Stepwise Refinement</h1>
<hr/>

<p>
	To a large extent, programming is the science of solving problems by computer. Because problems are often difficult, solutions—and the programs that implement those solutions—can be difficult as well. In order to make it easier for you to develop those solutions, you need to adopt a methodology and discipline that reduces the level of that complexity to a manageable scale.
</p>

<p>
	In the early years of programming, the concept of computing as a science was more or less an experiment in wishful thinking. No one knew much about programming in those days, and few thought of it as an engineering discipline in the conventional sense. As programming matured, however, such a discipline began to emerge. The cornerstone of that discipline is the understanding that programming is done in a social environment in which programmers must work together. If you go into industry, you will almost certainly be one of many programmers working to develop a large program. That program, moreover, is almost certain to live on and require maintenance beyond its originally intended application. Someone will want the program to include some new feature or work in some different way. When that occurs, a new team of programmers must go in and make the necessary changes in the programs. If programs are written in an individual style with little or no commonality, getting everyone to work together productively is extremely difficult.
</p>

<p>
	To combat this problem, programmers began to develop a set of programming methodologies that are collectively called <b>software engineering</b>. Using good software engineering skills not only makes it easier for other programmers to read and understand your programs, but also makes it easier for you to write those programs in the first place. One of the most important methodological advances to come out of software engineering is the strategy of <b>top-down design</b> or <b>stepwise refinement</b>, which consists of solving problems by starting with the problem as a whole. You break the whole problem down into pieces, and then solve each piece, breaking those down further if necessary. This top down strategy is complemented with  <b>iterative testing</b> where you make sure that the smaller pieces of the solution are working before moving on.
</p>

<h3>An exercise in stepwise refinement</h3>

<p>
	To illustrate the concept of stepwise refinement, let’s teach Karel to solve a new problem. Imagine that Karel is now living in a world that looks something like this:
</p>


<div class="section" id="world1">
    <div id ='world1Ide' class = "ide getStarted">
         <div id = 'world1CanvasDiv' class = 'commandCanvasDiv'>
          <div>
            <div class="commandCanvasOuter">
              <canvas id='world1Canvas' style="width:400px;"></canvas>
            </div>
          </div>
         </div> 
    </div>
    
<script>

        

function exampleworld1() {
 var karelIde = null;
 var buttonState = 'play';
 var canvas = null;

 function main() {
    canvas = document.getElementById('world1Canvas');
    karelIde = KarelIde('java',null, canvas, 'beeperTowers', 0, 'en',1000, 0.8 * 1000);
 }

 
 main()
 
}
exampleworld1();
    </script>
</div>
<p>
	On each of the columns, there is a tower of beepers of an unknown height, although some columns (such as the 7th, and 9th in the sample world) may be empty. Karel’s job is to collect all the beepers in each of these towers, put them back down on the easternmost corner of 1st row, and then return to its starting position. Thus, when Karel finishes its work in the example above, all 25 beepers currently in the towers should be stacked on the corner of 9th column and 1st row, as follows:
	</p>


<div class="section" id="world2">
    <div id ='world2Ide' class = "ide getStarted">
         <div id = 'world2CanvasDiv' class = 'commandCanvasDiv'>
          <div>
            <div class="commandCanvasOuter">
              <canvas id='world2Canvas' style="width:400px;"></canvas>
            </div>
          </div>
         </div> 
    </div>
    
<script>

        

function exampleworld2() {
 var karelIde = null;
 var buttonState = 'play';
 var canvas = null;

 function main() {
    canvas = document.getElementById('world2Canvas');
    karelIde = KarelIde('java',null, canvas, 'beeperTowersGoal', 0, 'en',1000, 0.8 * 1000);
 }

 
 main()
 
}
exampleworld2();
    </script>
</div>
<p>
	Importantly, you may assume that Karel initial <i>starts</i> with zero beepers in its bag. Each beeper picked up is added to its bag. When putting beepers in the corner, karel can use the <code>beepersInBag()</code> test.
	</p>

<p>
	The key to solving this problem is to decompose the program in the right way, while still being able to test as you go. This task is more complex than the others you have seen, which makes choosing appropriate subproblems more important to obtaining a successful solution.
	</p>

	<h3>The principle of top-down design</h3>

	<p>
		The key idea in stepwise refinement is that you should start the design of your program from the top, which refers to the level of the program that is conceptually highest and most abstract. At this level, the beeper tower problem is clearly divided into three independent phases. First, Karel has to collect all the beepers. Second, Karel has to deposit them on the last intersection. Third, Karel has to return to its home position. This conceptual decomposition of the problem suggests that the run method for this program will have the following structure:
	</p>

	<p class="demoCode" style="margin-left:10px">
<code>&nbsp;&nbsp;&nbsp;<span class="keyword">public void</span> run() {</code><br/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;collectAllBeepers();</code><br/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dropAllBeepers();</code><br/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;returnHome();</code><br/>
<code>&nbsp;&nbsp;&nbsp;}</code><br/>
</p>

<p>
	At this level, the problem is easy to understand. Of course, there are a few details left over in the form of methods that you have not yet written. Even so, it is important to look at each level of the decomposition and convince yourself that, as long as you believe that the methods you are about to write will solve the subproblems correctly, you will then have a solution to the problem as a whole.
</p>

<h3>Iterative testing as you go</h3>

<p>

Now that you have defined the structure for the program as a whole, it is time to move on to the first subproblem, which consists of collecting all the beepers. This task is itself more complicated than the simple problems from the preceding chapters. Collecting all the beepers means that you have to pick up the beepers in every tower until you get to the final corner. The fact that you need to repeat an operation for each tower suggests that you need a while loop here. The while loop will repeat the process of <code>collectOneTower</code> and then moving.	
</p>

<p><b>Caution:</b> It is dangerous to try to write the entire program without <b>testing</b> it as you go. If you make a mistake it will be hard to find the mistake. We know that we are going to repeat the process of collecting one tower. Let us write and <b>test</b> collecting a single tower before we put the <code>CollectOneTower</code> process in a for loop. Thus <i>temporariliy</i> we can start with the following definition of collectAllBeepers:

	<p class="demoCode" style="margin-left:10px">
<code>&nbsp;&nbsp;&nbsp;<span class="keyword">private void</span> collectAllBeepers() {</code><br/>
<code class="comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* temporary implementation for testing purposes */</code><br/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;collectOneTower();</code><br/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;move();</code><br/>
<code>&nbsp;&nbsp;&nbsp;}</code><br/>
</p>

<p>
	As a guiding principle, if you have a complex loop, test the <i>body</i> of the loop before you write the entire loop.
	</p>

<h3>Refining collect tower</h3>

<p>
	When collectOneTower is called, Karel is either standing at the base of a tower of beepers or standing on an empty corner. In the former case, you need to collect the beepers in the tower. In the latter, you can simply move on. This situation sounds like an application for the if statement, in which you would write something like this:
</p>

<p class="demoCode" style="margin-left:10px">
<code>&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>(beepersPresent()){</code><br/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;collectActualTower();</code><br/>
<code>&nbsp;&nbsp;&nbsp;}</code><br/>
</p>

<p>
	Before you add such a statement to the code, you should think about whether you need to make this test. Often, programs can be made much simpler by observing that cases that at first seem to be special can be treated in precisely the same way as the more general situation. In the current problem, what happens if you decide that there is a tower of beepers on every avenue but that some of those towers are zero beepers high? Making use of this insight simplifies the program because you no longer have to test whether there is a tower on a particular avenue.
</p>

<p>
	The collectOneTower method is still complex enough that an additional level of decomposition is in order. To collect all the beepers in a tower, Karel needs to undertake the following steps:
</p>

<ol>
	<li>Turn left to face the beepers in the tower.
<li>Collect all the beepers in the tower, stopping when no more beepers are found.
<li>Turn around to face back toward the bottom of the world.
<li>Return to the wall that represents the ground.
<li>Turn left to be ready to move to the next corner.
	</ol>

<p>
	Once again, this outline provides a model for the collectOneTower method, which looks like this:
</p>

<p class="demoCode" style="margin-left:10px">
<code>&nbsp;&nbsp;&nbsp;<span class="keyword">private void </span>collectOneTower(){</code><br/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;turnLeft();</code><br/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;collectLineOfBeepers();</code><br/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;turnAround();</code><br/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;moveToWall();</code><br/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;turnLeft();</code><br/>
<code>&nbsp;&nbsp;&nbsp;}</code><br/>
</p>

<h3>Method preconditions and postconditions</h3>

<p>
	The turnLeft commands at the beginning and end of the collectOneTower method are both critical to the correctness of this program. When collectOneTower is called, Karel is always somewhere on 1st row facing east. When it completes its operation, the program as a whole will work correctly only if Karel is again facing east at that same corner. Conditions that must be true before a method is called are referred to as <b>preconditions</b>; conditions that must apply after the method finishes are known as <b>postconditions</b>.
</p>

<p>
	When you define a method, you will get into far less trouble if you write down exactly what the pre- and postconditions are. Once you have done so, you then need to make sure that the code you write always leaves the postconditions satisfied, assuming that the preconditions were satisfied to begin with. For example, think about what happens if you call collectOneTower when Karel is on 1st row facing east. The first turnLeft command leaves Karel facing north, which means that Karel is properly aligned with the column of beepers representing the tower. The collectLineOfBeepers method—which has yet to be written but nonetheless performs a task that you understand conceptually— simply moves without turning. Thus, at the end of the call to collectLineOfBeepers, Karel will still be facing north. The turnAround call therefore leaves Karel facing south. Like collectLineOfBeepers, the moveToWall method does not involve any turns but instead simply moves until it hits the boundary wall. Because Karel is facing south, this boundary wall will be the one at the bottom of the screen, just below 1st row. The final turnLeft command therefore leaves Karel on 1st row facing east, which satisfies the postcondition.
</p>

<h3>Repeating the process</h3>

<p>You run your program and it successfully clears one tower and leaves Karel in the promised postcondition. Wahoo! You have just hit a milestone in solving this hard task! We now have to repeat the process of clearing one tower using a while loop.
</p>

<p>
	But what does this while loop look like? First of all, you should think about the conditional test. You want Karel to stop when it hits the wall at the end of the row. Thus, you want Karel to keep going as long as the space in front is clear. Thus, you know that the collectAllBeepers method will include a while loop that uses the frontIsClear test. At each position, you want Karel to collect all the beepers in the tower beginning on that corner. If you give that operation a name, which might be something like collectOneTower, you can go ahead and write a definition for the collectAllBeepers method even though you haven’t yet filled in the details.
</p>

<p>
	You do, however, have to be careful. The code for collectAllBeepers does not look like this:
</p>

<p class="demoCode" style="margin-left:10px">
<code>&nbsp;&nbsp;&nbsp;<span class="keyword">private void </span>collectAllBeepers(){</code><br/>
<code class="comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* buggy loop! */</code><br/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>(frontIsClear()) {</code><br/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;collectOneTower();</code><br/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;move();</code><br/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br/>
<code>&nbsp;&nbsp;&nbsp;}</code><br/>
</p>

<p>
	This implementation is buggy for exactly the same reason that the first version of the general PlaceBeeperLine from chapter 6 failed to do its job. There is a fencepost error in this version of the code, because Karel needs to test for the presence of a beeper tower on the last avenue. The correct implementation is:
</p>

<p class="demoCode" style="margin-left:10px">
<code>&nbsp;&nbsp;&nbsp;<span class="keyword">private void </span>collectAllBeepers(){</code><br/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>(frontIsClear()) {</code><br/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;collectOneTower();</code><br/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;move();</code><br/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;collectOneTower();</code><br/>
<code>&nbsp;&nbsp;&nbsp;}</code><br/>
</p>

<p>
	Note that this method has precisely the same structure as the main program from the PlaceBeeperLine program presented in chapter 6. The only difference is that this program calls collectOneTower where the other called putBeeper. These two programs are each examples of a general strategy that looks like this:
</p>

<p class="demoCode" style="margin-left:10px">
<code>&nbsp;&nbsp;&nbsp;<span class="keyword">private void </span>collectAllBeepers(){</code><br/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>(frontIsClear()) {</code><br/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><i class="demoText">perform some operation.</i><br/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;move();</code><br/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br/>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><i class="demoText" >perform the same operation for the final corner.</i><br/>
<code>&nbsp;&nbsp;&nbsp;}</code><br/>
</p>

<p>
	You can use this strategy whenever you need to perform an operation on every corner as you move along a path that ends at a wall. If you remember the general structure of this strategy, you can use it whenever you encounter a problem that requires such an operation. Reusable strategies of this sort come up frequently in programming and are referred to as <b>programming idioms</b> or <b>patterns</b>. The more patterns you know, the easier it will be for you to find one that fits a particular type of problem.
</p>

<h3>Finishing up</h3>

<p>Although the hard work has been done, there are still several loose ends that need to be resolved. The main program calls two methods—dropAllBeepers and returnHome— that are as yet unwritten. Similarly, collectOneTower calls collectLineOfBeepers and moveToWall. Fortunately, all four of these methods are simple enough to code without any further decomposition, particularly if you use moveToWall in the definition of returnHome. Here is the complete implementation:</p>



<div class="section embeddedIde" id="beeperTowers">
    <div id ='beeperTowersIde' class = "ide getStarted" style="height:1649.7px">
      <div id = 'beeperTowersIdeCenter' class = "ideCenter" style="height:inherit;">
         <div id = 'beeperTowersEditorDiv' style="width:600px;height:inherit;"></div>
         
      </div>
    </div>
    <div id='beeperTowersCanvasDiv' style="width:500px;height:360px">
        <canvas id='beeperTowersCanvas' class = 'ideCanvas'></canvas>
    </div>
    <div style="width:100%;">
        <div class="buttonBar">
           <button class="btn btn-default" id="beeperTowersRunButton"><span class="glyphicon glyphicon-play"></span> Run Program</button>
        </div> 
    </div>
<script>

        

function examplebeeperTowers() {
STARTER_CODE = `
/*
 * File: BeeperCollectingKarel.java
 * --------------------------------
 * The BeeperCollectingKarel class collects all the beepers
 * in a series of vertical towers and deposits them at the
 * eastmost corner on 1st row.
 */
import stanford.karel.*;
public class BeeperCollectingKarel extends Karel {

   /**
    * Specifies the program entry point.
    */
   public void run() {
      collectAllBeepers();
      dropAllBeepers();
      returnHome();
   }

   /**
    * Collects the beepers from every tower by moving along 1st
    * row, calling collectOneTower at every corner.  The
    * postcondition for this method is that Karel is in the
    * easternmost corner of 1st row facing east.
    */
   private void collectAllBeepers() {
      while (frontIsClear()) {
         collectOneTower();
         move(); 
      }
      collectOneTower();
   }

   /**
    * Collects the beepers in a single tower. When collectOneTower
    * is called, Karel must be on 1st row facing east.  The
    * postcondition for collectOneTower is that Karel must again
    * be facing east on that same corner.
    */
   private void collectOneTower() {
      turnLeft();
      collectLineOfBeepers();
      turnAround();
      moveToWall();
      turnLeft();
   }

   /**
    * Collects a consecutive line of beepers. The end of the beeper
    * line is indicated by a corner that contains no beepers.
    */
   private void collectLineOfBeepers() {
      while (beepersPresent()) {
         pickBeeper();
         if (frontIsClear()) {
            move(); 
         }
      } 
   }

   /**
    * Drops all the beepers on the current corner.
    */
   private void dropAllBeepers() {
      while (beepersInBag()) {
         putBeeper();
      }
   }

   /**
    * Returns Karel to its initial position at the corner of 1st
    * Avenue and 1st row, facing east.  The precondition for this
    * method is that Karel must be facing east somewhere on 1st
    * row, which is true at the conclusion of collectAllBeepers.
    */
   private void returnHome() {
      turnAround();
      moveToWall();
      turnAround();
   }

   /** Moves Karel forward until it is blocked by a wall. */
   private void moveToWall(){
      while (frontIsClear()) {
         move();
      } 
   }

   /** Turns Karel 180 degrees around */
   private void turnAround(){
      turnLeft();
      turnLeft();
   }
}`
// because of that extra endline at the start of the string
STARTER_CODE = STARTER_CODE.trim();

 var karelIde = null;
 var karelEditor = null;
 var buttonState = 'play';

 function main() {
   karelEditor = importEditorCode('beeperTowersEditor','beeperTowersEditorDiv', STARTER_CODE, false);
     //importRunButtonBar('example1ButtonBar');
    
    $("[title]").tooltip({ position: "bottom center", opacity: 0.9});
    
    initTabs();
    var canvas = document.getElementById('beeperTowersCanvas');
    karelIde = KarelIde('java',karelEditor, canvas, 'beeperTowers', 0.9, 'en', 1000, 
      0.8 * 1000);
    $('#beeperTowersRunButton').click(function(){playClicked()});
    onresize();
 }

 function playClicked() {
  if(buttonState == 'play') {
    karelIde.playButton();
      
      var resetText = '<span class="glyphicon glyphicon-repeat"></span> Reset Program';
      $('#beeperTowersRunButton').html(resetText);
      buttonState = 'reset';
     } else if (buttonState == 'reset') {
      karelIde.stopButton();
      var playText = '<span class="glyphicon glyphicon-play"></span> Run Program';
      $('#beeperTowersRunButton').html(playText);
      buttonState = 'play';
     }
    
  }

  function onresize() { 

    // var parentHeight = 1649.7;
    // var canvasWidth = 300
    // var parentWidth = $("#beeperTowers").width();
    // console.log('pw: ' + parentWidth);

    // var editorDiv = document.getElementById('beeperTowersCanvasDiv');
    // var canvas = document.getElementById('beeperTowersCanvas');
    


    // var availibleWidth = parentWidth;
    // var elementSpacing = 12;

    // var editorWidth = availibleWidth - canvasWidth - elementSpacing; 

    // canvas.style.width = canvasWidth + 'px';
    // canvas.style.height = canvasWidth + 'px';
    // canvas.style.left = (editorWidth + elementSpacing) + 'px';
 }

 
 main()
 
}
examplebeeperTowers();
    </script>
</div>
<hr/>
<center>
  <a class="btn btn-primary btn-lg" href="chapter9.html" role="button">Next Chapter</a>
</center>
</p>

<div style="height:60px"></div>        </div>
      </div>

      </div>
      <!-- right gutter -->
      <div style="flex-grow:4"></div>
    </div>
  </div>
</body> 
</html>
