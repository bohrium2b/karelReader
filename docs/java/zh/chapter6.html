
<html>
<head>

<title>卡雷尔读者</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/> 
<script src="../../plugins/jquery.min.js"></script>
<link href="../../plugins/bootstrap/css/bootstrap.min.css" rel="stylesheet"/> 
<script src="../../plugins/bootstrap/js/bootstrap.min.js"></script>
<link href="../../style.css" rel="stylesheet"/> 
<script src="../..//karel/js/html/websiteImports.js"></script>
<script>importCss();</script>
<script>importJs();</script>
</head>
<body>
<!-- container -->
<div class="bookContainer">

<!-- side bar -->
<div class="bookSideBar">
<div class="homeLink">
 <a href="../../java/zh/intro.html">
<span aria-hidden="true" class="glyphicon glyphicon-home"></span> 卡雷尔</a> 
</div>
<hr/>
<div class="chapterTab" onclick="location.href='../../java/zh/chapter1.html'">
<a class="bookLink btn btn-link" href="../../java/zh/chapter1.html">1  - 遇见卡雷尔</a> 
</div>
<div class="chapterTab" onclick="location.href='../../java/zh/chapter2.html'">
<a class="bookLink btn btn-link" href="../../java/zh/chapter2.html">2  - 编程</a> 
</div>
<div class="chapterTab" onclick="location.href='../../java/zh/chapter3.html'">
<a class="bookLink btn btn-link" href="../../java/zh/chapter3.html">3  - 新方法</a> 
</div>
<div class="chapterTab" onclick="location.href='../../java/zh/chapter4.html'">
<a class="bookLink btn btn-link" href="../../java/zh/chapter4.html">4  - 分解</a> 
</div>
<div class="chapterTab" onclick="location.href='../../java/zh/chapter5.html'">
<a class="bookLink btn btn-link" href="../../java/zh/chapter5.html">5  - 对于循环</a> 
</div>
<div class="chapterTab" onclick="location.href='../../java/zh/chapter6.html'">
<a class="bookLink btn btn-link" href="../../java/zh/chapter6.html">6  - 循环时</a> 
</div>
<div class="chapterTab" onclick="location.href='../../java/zh/chapter7.html'">
<a class="bookLink btn btn-link" href="../../java/zh/chapter7.html">7  - 条件</a> 
</div>
<div class="chapterTab" onclick="location.href='../../java/zh/chapter8.html'">
<a class="bookLink btn btn-link" href="../../java/zh/chapter8.html">8  - 细化</a> 
</div>
<div class="chapterTab" onclick="location.href='../../java/zh/chapter9.html'">
<a class="bookLink btn btn-link" href="../../java/zh/chapter9.html">9  - 超级卡雷尔</a> 
</div>
<div class="chapterTab" onclick="location.href='../../java/zh/reference.html'">
<a class="bookLink btn btn-link" href="../../java/zh/reference.html">10  - 参考</a> 
</div>
<div class="chapterTab" onclick="location.href='../../java/zh/ide.html'">
<a class="bookLink btn btn-link" href="../../java/zh/ide.html">11  - 代码</a> 
</div>
<hr/>
 <a href="../../"><img src="../../images/unFlag.png" style="width:40px"/> 学到更多</a> 
<!-- <center>
    <img style ="width:75px;" src="../../images/stanford.png"/> 
    </center> -->
</div>
<!-- content -->
<div class="bookContent" style="display: flex;">
<!-- right gutter -->
<div style="flex-grow:1;max-width:50px;"></div>
<!-- main stuff -->
<div class="" style="flex-basis:740px; max-width:740px; margin-left:20px; margin-right:20px">
<div class="row">
<div class="col-md-12 col-xs-12">


<h1>第6章：循环</h1>
<hr/>
<p>定义新方法和定义循环的技术 - 尽管它们很有用 - 实际上并不能使Karel解决任何新问题。每当你run一个程序，它总是做同样的事情。当程序对不同的输入做出不同的响应时，程序会变得更有用。</p>
<p>举个例子。假设您想编写一个程序，将Karel move放到墙上。但是，您并不只是希望这个程序能够在一个固定大小的世界上运行。您想编写一个可以在任何世界上运行的程序。</p>





<div class="section embeddedIde" id="moveToWall">
<div class="ide getStarted" id="moveToWallIde" style="height:334.40000000000003px">
<div class="ideCenter" id="moveToWallIdeCenter">
<div class="ideEditorDiv" id="moveToWallEditorDiv" style="width:200px"></div>
<div class="ideCanvasDiv" id="moveToWallCanvasDiv">
<div class="worldDropdown">
<div class="dropdown">
<button aria-expanded="true" aria-haspopup="true" class="btn btn-default dropdown-toggle" data-toggle="dropdown" id="dropdownMenu1" type="button">改变世界<span class="caret"></span>
</button>
<ul aria-labelledby="dropdownMenu1" class="dropdown-menu" id="moveToWallWorlds">
<li><a>1x1的</a> </li>
<li><a>4×4</a> </li>
<li><a>3×6</a> </li>
<li><a>7×7</a> </li>
<li><a>8×8</a> </li>
</ul>
</div>
</div>
<canvas class="ideCanvas" id="moveToWallCanvas"></canvas>
</div>
</div>
</div>
<div style="width:100%;">
<div class="buttonBar">
<button class="btn btn-default" id="moveToWallRunButton"><span class="glyphicon glyphicon-play"></span>运行程序</button>
</div>
</div>
<script>

        

function examplemoveToWall() {
STARTER_CODE = `

/*
 * 文件：移动到墙.java
 * -----------
 * 使用“while”循环到move 卡雷尔，直到
 * 撞到墙壁。适用于任何规模的世界。
 */
import stanford.卡雷尔.*;
public class Move到墙 extends 卡雷尔 {
   public void run() {
      move到墙();
   }

   /* 这是一个非常有用的方法 */
   private void move到墙() {
      while(frontIsClear()) {
         move();
      }
   } 
}
`
// because of that extra endline at the start of the string
STARTER_CODE = STARTER_CODE.trim();

 var karelIde = null;
 var karelEditor = null;
 var buttonState = 'play';

 function main() {
   karelEditor = importEditorCode('moveToWallEditor','moveToWallEditorDiv', STARTER_CODE, false);
    setupWorldDropdown();
    
    
    var canvas = document.getElementById('moveToWallCanvas');
    karelIde = KarelIde('java',karelEditor, canvas, '7x7', 0.0, 'zh');
    $('#moveToWallRunButton').click(function(){playClicked()});
    onresize();
    
 }

 function setupWorldDropdown() {
    console.log('setup world dropdown')
    let ul = document.getElementById('moveToWallWorlds')
    
    if (!ul.childNodes || ul.childNodes.length == 0) return;

    // Iterate LIs
    for (var itemi=0;itemi<ul.childNodes.length;itemi++) {
        var li = ul.childNodes[itemi];
        if(li.nodeName == "LI") {
          var a = li.childNodes[0]
          let worldName = a.innerHTML;
          console.log(worldName)
          a.onclick = () => setWorld(worldName);

        }
    }
 }

 function setWorld(worldName){
    console.log('here we go', worldName)
    karelIde.changeWorld(worldName)
    changeToPlayButton()
 }

 function playClicked() {
  if(buttonState == 'play') {
    karelIde.playButton();
    changeToResetButton();
   } else if (buttonState == 'reset') {
    karelIde.stopButton();
    changeToPlayButton();
   }
  }

  function changeToPlayButton() {
    var playText = '<span class="glyphicon glyphicon-play"></span> Run Program';
    $('#moveToWallRunButton').html(playText);
    buttonState = 'play';
  }

  function changeToResetButton() {
    var resetText = '<span class="glyphicon glyphicon-repeat"></span> Reset Program';
    $('#moveToWallRunButton').html(resetText);
    buttonState = 'reset';  
  }

 function onresize() { 
    var parentHeight = 334.40000000000003;
    var canvasWidth = 300
    var parentWidth = $("#moveToWall").width();
    console.log('pw: ' + parentWidth);

    var ide = document.getElementById('moveToWallIde');
    var editorDiv = document.getElementById('moveToWallEditorDiv');
    var canvas = document.getElementById('moveToWallCanvasDiv');
    
    var ideHeight = parentHeight
    var centerHeight = ideHeight;

    var availibleWidth = parentWidth;
    var elementSpacing = 12;

    var editorWidth = availibleWidth - canvasWidth - elementSpacing; 

    canvas.style.width = canvasWidth + 'px';
    canvas.style.height = canvasWidth + 'px';
    canvas.style.left = (editorWidth + elementSpacing) + 'px';



    editorDiv.style.left = 0 + 'px'
    editorDiv.style.width = editorWidth + 'px';
    editorDiv.style.height = parentHeight + 'px';
    console.log('editor width: ' + editorWidth)

    if (karelEditor) {
       karelEditor.renderer.onResize();
    }
 }
 main()
 
}
examplemoveToWall();
    </script>
</div>

<p>点击世界上方的“更改世界”下拉菜单，尝试改变世界。对于任何规模的世界，卡雷尔将move直到它撞墙。请注意，使用a不能完成此专长 <code class="keyword">for</code> 环。这需要我们在编程时了解世界的大小。</p>
<h3>基本的循环</h3>
<p>在卡雷尔，一个 <code class="keyword">while</code> 循环用于重复代码体<i>只要</i>给定条件成立。 while循环具有以下一般形式：</p>
<p class="demoCode">
 <code><span class="keyword">while</span>(</code> <i class="demoText">测试</i> <code>){</code> <br/>
<i class="demoText" style="margin-left:2em">要重复的陈述</i><br/>
 <code>}</code> 
</p>
<p>while循环的控制流程如下。当程序遇到while循环时，它开始重复一个进程<i>检查</i>如果测试通过，如果是，<i>run s</i>身体中的代码。</p>当程序<i>检查</i>如果测试通过，它决定是否通过<i class="demoText">测试</i>对于当前的世界状况是正确的。如果是这样，循环将run的代码。如果测试失败，则循环结束并且程序move打开。
<p>当程序<i>run s</i>循环体，程序一次一个地执行体内的线条。当程序到达while循环结束时，它会跳回到循环的顶部。然后重新检查测试，如果通过则继续循环。程序在进行检查之前不会退出循环，并且测试失败。</p>
<p>卡雷尔有很多<i class="demoText">测试</i>声明，我们将在下一章中讨论所有这些。现在我们将使用一个测试语句： <code>frontIsClear()</code> 如果没有直接面对卡雷尔的墙，这是真的。</p>
<h3>Fencepost Bug</h3>
<p>让我们修改上面的程序，使其更有趣。卡雷尔不是只是移动到墙上，而是在每个方格中放置一条锥体秒的线。我们再次希望这个程序适用于任何规模的世界：</p>





<div class="section embeddedIde" id="beeperLineBug1">
<div class="ide getStarted" id="beeperLineBug1Ide" style="height:316.8px">
<div class="ideCenter" id="beeperLineBug1IdeCenter">
<div class="ideEditorDiv" id="beeperLineBug1EditorDiv" style="width:200px"></div>
<div class="ideCanvasDiv" id="beeperLineBug1CanvasDiv">
<div class="worldDropdown">
<div class="dropdown">
<button aria-expanded="true" aria-haspopup="true" class="btn btn-default dropdown-toggle" data-toggle="dropdown" id="dropdownMenu1" type="button">改变世界<span class="caret"></span>
</button>
<ul aria-labelledby="dropdownMenu1" class="dropdown-menu" id="beeperLineBug1Worlds">
<li><a>1x1的</a> </li>
<li><a>4×4</a> </li>
<li><a>3×6</a> </li>
<li><a>7×7</a> </li>
<li><a>8×8</a> </li>
</ul>
</div>
</div>
<canvas class="ideCanvas" id="beeperLineBug1Canvas"></canvas>
</div>
</div>
</div>
<div style="width:100%;">
<div class="buttonBar">
<button class="btn btn-default" id="beeperLineBug1RunButton"><span class="glyphicon glyphicon-play"></span>运行程序</button>
</div>
</div>
<script>

        

function examplebeeperLineBug1() {
STARTER_CODE = `

/*
 * 文件：锥体行Bug.java
 * -------------
 * 使用while循环放置一条锥体 s的行。该程序适用
 * 于任何规模的世界。然而，因为每个世界需要一个较少move总比putBeeper的IT总是错过了锥体 。
 */
import stanford.卡雷尔.*;
public class 锥体行Bug extends 卡雷尔 {
   public void run() {
   	  /* 重复，直到卡雷尔面临一堵墙 */
      while(frontIsClear()) {
      	 /* 在当前的广场上放置一个锥体 */ 
         putBeeper();
      	 /* move到下一个广场 */
         move();
      }
   }
}
`
// because of that extra endline at the start of the string
STARTER_CODE = STARTER_CODE.trim();

 var karelIde = null;
 var karelEditor = null;
 var buttonState = 'play';

 function main() {
   karelEditor = importEditorCode('beeperLineBug1Editor','beeperLineBug1EditorDiv', STARTER_CODE, true);
    setupWorldDropdown();
    
    
    var canvas = document.getElementById('beeperLineBug1Canvas');
    karelIde = KarelIde('java',karelEditor, canvas, '7x7', 0.0, 'zh');
    $('#beeperLineBug1RunButton').click(function(){playClicked()});
    onresize();
    
 }

 function setupWorldDropdown() {
    console.log('setup world dropdown')
    let ul = document.getElementById('beeperLineBug1Worlds')
    
    if (!ul.childNodes || ul.childNodes.length == 0) return;

    // Iterate LIs
    for (var itemi=0;itemi<ul.childNodes.length;itemi++) {
        var li = ul.childNodes[itemi];
        if(li.nodeName == "LI") {
          var a = li.childNodes[0]
          let worldName = a.innerHTML;
          console.log(worldName)
          a.onclick = () => setWorld(worldName);

        }
    }
 }

 function setWorld(worldName){
    console.log('here we go', worldName)
    karelIde.changeWorld(worldName)
    changeToPlayButton()
 }

 function playClicked() {
  if(buttonState == 'play') {
    karelIde.playButton();
    changeToResetButton();
   } else if (buttonState == 'reset') {
    karelIde.stopButton();
    changeToPlayButton();
   }
  }

  function changeToPlayButton() {
    var playText = '<span class="glyphicon glyphicon-play"></span> Run Program';
    $('#beeperLineBug1RunButton').html(playText);
    buttonState = 'play';
  }

  function changeToResetButton() {
    var resetText = '<span class="glyphicon glyphicon-repeat"></span> Reset Program';
    $('#beeperLineBug1RunButton').html(resetText);
    buttonState = 'reset';  
  }

 function onresize() { 
    var parentHeight = 316.8;
    var canvasWidth = 300
    var parentWidth = $("#beeperLineBug1").width();
    console.log('pw: ' + parentWidth);

    var ide = document.getElementById('beeperLineBug1Ide');
    var editorDiv = document.getElementById('beeperLineBug1EditorDiv');
    var canvas = document.getElementById('beeperLineBug1CanvasDiv');
    
    var ideHeight = parentHeight
    var centerHeight = ideHeight;

    var availibleWidth = parentWidth;
    var elementSpacing = 12;

    var editorWidth = availibleWidth - canvasWidth - elementSpacing; 

    canvas.style.width = canvasWidth + 'px';
    canvas.style.height = canvasWidth + 'px';
    canvas.style.left = (editorWidth + elementSpacing) + 'px';



    editorDiv.style.left = 0 + 'px'
    editorDiv.style.width = editorWidth + 'px';
    editorDiv.style.height = parentHeight + 'px';
    console.log('editor width: ' + editorWidth)

    if (karelEditor) {
       karelEditor.renderer.onResize();
    }
 }
 main()
 
}
examplebeeperLineBug1();
    </script>
</div>

<p>那看起来很棒。除了一个问题。在每个世界上，卡雷尔都没有锥体的最后一个锥体上放置锥体 （仔细观察）。当卡雷尔位于最后一个方格时，程序不会执行循环体，因为测试不再通过 - 卡雷尔面向墙。你可能想尝试切换身体的秩序，使卡雷尔move小号放置beeer之前。代码是可编辑的，所以去试试吧！</p>
<p>存在一个更深层次的问题，即身体的重排不能解决。对于有7列的世界，卡雷尔需要投入7 锥体 s，但应该只有move 6次。由于while循环在测试通过时执行两行，如何让程序比另一行更多地执行一个命令？</p>
<p>这个程序中的错误是一个称为a的编程问题的例子 <b>fencepost错误</b> 。这个名字的来源是这样一个事实：如果你想建造一个由任何尺寸都有一个栅栏柱的面板制成的栅栏，栅栏柱的数量总是大于窗格的数量。例如，你需要多少个栅栏柱来建造一个有10个面板的栅栏？答案是11，如下图所示：</p>
<center>
<img src="../../images/ch6/fencepost.png" style="width:500px;margin-bottom:10px"/> 
</center>
<p>一旦你发现它，修复这个错误实际上很容易。在卡雷尔停在世界末日之前，该计划所要做的就是下一个锥体 ：</p>





<div class="section embeddedIde" id="beeperLine">
<div class="ide getStarted" id="beeperLineIde" style="height:352.0px">
<div class="ideCenter" id="beeperLineIdeCenter">
<div class="ideEditorDiv" id="beeperLineEditorDiv" style="width:200px"></div>
<div class="ideCanvasDiv" id="beeperLineCanvasDiv">
<div class="worldDropdown">
<div class="dropdown">
<button aria-expanded="true" aria-haspopup="true" class="btn btn-default dropdown-toggle" data-toggle="dropdown" id="dropdownMenu1" type="button">改变世界<span class="caret"></span>
</button>
<ul aria-labelledby="dropdownMenu1" class="dropdown-menu" id="beeperLineWorlds">
<li><a>1x1的</a> </li>
<li><a>4×4</a> </li>
<li><a>3×6</a> </li>
<li><a>7×7</a> </li>
<li><a>8×8</a> </li>
</ul>
</div>
</div>
<canvas class="ideCanvas" id="beeperLineCanvas"></canvas>
</div>
</div>
</div>
<div style="width:100%;">
<div class="buttonBar">
<button class="btn btn-default" id="beeperLineRunButton"><span class="glyphicon glyphicon-play"></span>运行程序</button>
</div>
</div>
<script>

        

function examplebeeperLine() {
STARTER_CODE = `

/*
 * 文件：锥体行.java
 * ----------
 * 使用“while”循环放置锥体 s的行。该程序适用
 * 于任何规模的世界。
 */
import stanford.卡雷尔.*;
public class 锥体行 extends 卡雷尔 {
   public void run() {
      /* 重复，直到卡雷尔面临一堵墙 */
      while(frontIsClear()) {
         /* 在当前的广场上放置一个锥体 */ 
         putBeeper();
         /* move到下一个广场 */
         move();
      }
      /* 解决了围栏后的错误 */
      putBeeper();
   }
}
`
// because of that extra endline at the start of the string
STARTER_CODE = STARTER_CODE.trim();

 var karelIde = null;
 var karelEditor = null;
 var buttonState = 'play';

 function main() {
   karelEditor = importEditorCode('beeperLineEditor','beeperLineEditorDiv', STARTER_CODE, true);
    setupWorldDropdown();
    
    
    var canvas = document.getElementById('beeperLineCanvas');
    karelIde = KarelIde('java',karelEditor, canvas, '7x7', 0.8, 'zh');
    $('#beeperLineRunButton').click(function(){playClicked()});
    onresize();
    
 }

 function setupWorldDropdown() {
    console.log('setup world dropdown')
    let ul = document.getElementById('beeperLineWorlds')
    
    if (!ul.childNodes || ul.childNodes.length == 0) return;

    // Iterate LIs
    for (var itemi=0;itemi<ul.childNodes.length;itemi++) {
        var li = ul.childNodes[itemi];
        if(li.nodeName == "LI") {
          var a = li.childNodes[0]
          let worldName = a.innerHTML;
          console.log(worldName)
          a.onclick = () => setWorld(worldName);

        }
    }
 }

 function setWorld(worldName){
    console.log('here we go', worldName)
    karelIde.changeWorld(worldName)
    changeToPlayButton()
 }

 function playClicked() {
  if(buttonState == 'play') {
    karelIde.playButton();
    changeToResetButton();
   } else if (buttonState == 'reset') {
    karelIde.stopButton();
    changeToPlayButton();
   }
  }

  function changeToPlayButton() {
    var playText = '<span class="glyphicon glyphicon-play"></span> Run Program';
    $('#beeperLineRunButton').html(playText);
    buttonState = 'play';
  }

  function changeToResetButton() {
    var resetText = '<span class="glyphicon glyphicon-repeat"></span> Reset Program';
    $('#beeperLineRunButton').html(resetText);
    buttonState = 'reset';  
  }

 function onresize() { 
    var parentHeight = 352.0;
    var canvasWidth = 300
    var parentWidth = $("#beeperLine").width();
    console.log('pw: ' + parentWidth);

    var ide = document.getElementById('beeperLineIde');
    var editorDiv = document.getElementById('beeperLineEditorDiv');
    var canvas = document.getElementById('beeperLineCanvasDiv');
    
    var ideHeight = parentHeight
    var centerHeight = ideHeight;

    var availibleWidth = parentWidth;
    var elementSpacing = 12;

    var editorWidth = availibleWidth - canvasWidth - elementSpacing; 

    canvas.style.width = canvasWidth + 'px';
    canvas.style.height = canvasWidth + 'px';
    canvas.style.left = (editorWidth + elementSpacing) + 'px';



    editorDiv.style.left = 0 + 'px'
    editorDiv.style.width = editorWidth + 'px';
    editorDiv.style.height = parentHeight + 'px';
    console.log('editor width: ' + editorWidth)

    if (karelEditor) {
       karelEditor.renderer.onResize();
    }
 }
 main()
 
}
examplebeeperLine();
    </script>
</div><hr/>
<center>
<a class="btn btn-primary btn-lg" href="chapter7.html" role="button">下一章</a> 
</center>




<div style="height:60px"></div>
</div>
</div>
</div>
<!-- right gutter -->
<div style="flex-grow:4"></div>
</div>
</div>
</body>
</html>
