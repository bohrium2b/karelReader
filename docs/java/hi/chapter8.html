
<html>
<head>

<title>करेल पाठक</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/> 
<script src="../../plugins/jquery.min.js"></script>
<link href="../../plugins/bootstrap/css/bootstrap.min.css" rel="stylesheet"/> 
<script src="../../plugins/bootstrap/js/bootstrap.min.js"></script>
<link href="../../style.css" rel="stylesheet"/> 
<script src="../..//karel/js/html/websiteImports.js"></script>
<script>importCss();</script>
<script>importJs();</script>
</head>
<body>
<!-- container -->
<div class="bookContainer">

<!-- side bar -->
<div class="bookSideBar">
<div class="homeLink">
 <a href="../../java/hi/intro.html">
<span aria-hidden="true" class="glyphicon glyphicon-home"></span> कैरेल</a> 
</div>
<hr/>
<div class="chapterTab" onclick="location.href='../../java/hi/chapter1.html'">
<a class="bookLink btn btn-link" href="../../java/hi/chapter1.html">1 - कैरेल से मिलते हैं</a> 
</div>
<div class="chapterTab" onclick="location.href='../../java/hi/chapter2.html'">
<a class="bookLink btn btn-link" href="../../java/hi/chapter2.html">2 - प्रोग्रामिंग</a> 
</div>
<div class="chapterTab" onclick="location.href='../../java/hi/chapter3.html'">
<a class="bookLink btn btn-link" href="../../java/hi/chapter3.html">3 - नए तरीके</a> 
</div>
<div class="chapterTab" onclick="location.href='../../java/hi/chapter4.html'">
<a class="bookLink btn btn-link" href="../../java/hi/chapter4.html">4 - अपघटन</a> 
</div>
<div class="chapterTab" onclick="location.href='../../java/hi/chapter5.html'">
<a class="bookLink btn btn-link" href="../../java/hi/chapter5.html">5 - लूप्स के लिए</a> 
</div>
<div class="chapterTab" onclick="location.href='../../java/hi/chapter6.html'">
<a class="bookLink btn btn-link" href="../../java/hi/chapter6.html">6 - जबकि लूप्स</a> 
</div>
<div class="chapterTab" onclick="location.href='../../java/hi/chapter7.html'">
<a class="bookLink btn btn-link" href="../../java/hi/chapter7.html">7 - सशर्त</a> 
</div>
<div class="chapterTab" onclick="location.href='../../java/hi/chapter8.html'">
<a class="bookLink btn btn-link" href="../../java/hi/chapter8.html">8 - शोधन</a> 
</div>
<div class="chapterTab" onclick="location.href='../../java/hi/chapter9.html'">
<a class="bookLink btn btn-link" href="../../java/hi/chapter9.html">9 - सुपरकारेल</a> 
</div>
<div class="chapterTab" onclick="location.href='../../java/hi/reference.html'">
<a class="bookLink btn btn-link" href="../../java/hi/reference.html">10 - संदर्भ</a> 
</div>
<div class="chapterTab" onclick="location.href='../../java/hi/ide.html'">
<a class="bookLink btn btn-link" href="../../java/hi/ide.html">11 - कोड</a> 
</div>
<hr/>
 <a href="../../"><img src="../../images/unFlag.png" style="width:40px"/> और अधिक जानें</a> 
<!-- <center>
    <img style ="width:75px;" src="../../images/stanford.png"/> 
    </center> -->
</div>
<!-- content -->
<div class="bookContent" style="display: flex;">
<!-- right gutter -->
<div style="flex-grow:1;max-width:50px;"></div>
<!-- main stuff -->
<div class="" style="flex-basis:740px; max-width:740px; margin-left:20px; margin-right:20px">
<div class="row">
<div class="col-md-12 col-xs-12">


<h1>अध्याय 8: स्टेपवाइज शोधन</h1>
<hr/>
<p>काफी हद तक, प्रोग्रामिंग कंप्यूटर द्वारा समस्याओं को हल करने का विज्ञान है। क्योंकि समस्याएँ अक्सर कठिन होती हैं, समाधान- और उन समाधानों को लागू करने वाले कार्यक्रम- मुश्किल भी हो सकते हैं। आपके लिए उन समाधानों को विकसित करना आसान बनाने के लिए, आपको एक ऐसी पद्धति और अनुशासन को अपनाने की आवश्यकता है जो उस जटिलता के स्तर को एक प्रबंधनीय पैमाने पर कम कर दे।</p>
<p>प्रोग्रामिंग के शुरुआती वर्षों में, विज्ञान के रूप में कंप्यूटिंग की अवधारणा इच्छाधारी सोच में एक प्रयोग था। उन दिनों में प्रोग्रामिंग के बारे में कोई भी ज्यादा नहीं जानता था, और कुछ ने पारंपरिक अर्थों में इंजीनियरिंग अनुशासन के रूप में सोचा था। जैसे-जैसे प्रोग्रामिंग परिपक्व हुई, वैसे-वैसे इस तरह का अनुशासन उभरने लगा। उस अनुशासन की आधारशिला यह समझ है कि प्रोग्रामिंग एक सामाजिक वातावरण में की जाती है जिसमें प्रोग्रामर को एक साथ काम करना होगा। यदि आप उद्योग में जाते हैं, तो आप निश्चित रूप से एक बड़े कार्यक्रम को विकसित करने के लिए काम कर रहे कई प्रोग्रामर में से एक होंगे। इसके अलावा, इस कार्यक्रम को जीना लगभग निश्चित है और इसके मूल रूप से इच्छित अनुप्रयोग से परे रखरखाव की आवश्यकता है। कोई व्यक्ति चाहेगा कि कार्यक्रम में कुछ नई सुविधा शामिल हो या कुछ अलग तरीके से काम किया जा सके। जब ऐसा होता है, तो प्रोग्रामर की एक नई टीम को कार्यक्रमों में जाना चाहिए और आवश्यक बदलाव करने चाहिए। यदि कार्यक्रमों को एक व्यक्तिगत शैली में बहुत कम या बिना किसी समानता के लिखा जाता है, तो हर किसी को एक साथ काम करना बेहद मुश्किल होता है।</p>
<p>इस समस्या से निपटने के लिए, प्रोग्रामर ने प्रोग्रामिंग पद्धति का एक समूह विकसित करना शुरू किया, जिसे सामूहिक रूप से कहा जाता है <b>सॉफ्टवेयर इंजीनियरिंग</b> । अच्छे सॉफ्टवेयर इंजीनियरिंग कौशल का उपयोग करने से न केवल अन्य प्रोग्रामरों के लिए आपके कार्यक्रमों को पढ़ना और समझना आसान हो जाता है, बल्कि आपके लिए उन कार्यक्रमों को पहली बार में लिखना भी आसान हो जाता है। सॉफ्टवेयर इंजीनियरिंग से बाहर आने के लिए सबसे महत्वपूर्ण कार्यप्रणाली में से एक रणनीति है <b>ऊपर से नीचे डिजाइन</b> या <b>चरणबद्ध शोधन</b> , जिसमें समग्र रूप से समस्या को शुरू करके समस्याओं को हल करना शामिल है। आप पूरी समस्या को टुकड़ों में तोड़ते हैं, और फिर प्रत्येक टुकड़े को हल करते हैं, यदि आवश्यक हो तो आगे नीचे तोड़ते हैं। यह टॉप डाउन रणनीति के साथ पूरक है <b>पुनरावृत्त परीक्षण</b> जहाँ आप सुनिश्चित करें कि समाधान के छोटे टुकड़े आगे बढ़ने से पहले काम कर रहे हैं।</p>
<h3>स्टेप वाइज शोधन में एक व्यायाम</h3>
<p>स्टेप वाइज शोधन की अवधारणा को समझने के लिए, करेल को एक नई समस्या को हल करने के लिए सिखाते हैं। कल्पना कीजिए कि कारेल अब एक ऐसी दुनिया में रह रहे हैं जो कुछ इस तरह दिखती है:</p>





<div class="section" id="world1">
<div class="ide getStarted" id="world1Ide">
<div class="commandCanvasDiv" id="world1CanvasDiv">
<div>
<div class="commandCanvasOuter">
<canvas id="world1Canvas" style="width:400px;"></canvas>
</div>
</div>
</div>
</div>
<script>

        

function exampleworld1() {
 var karelIde = null;
 var buttonState = 'play';
 var canvas = null;

 function main() {
    canvas = document.getElementById('world1Canvas');
    karelIde = KarelIde('java',null, canvas, 'beeperTowers', 0, 'hi',1000, 0.8 * 1000);
 }

 
 main()
 
}
exampleworld1();
    </script>
</div>

<p>प्रत्येक स्तंभ पर, अज्ञात ऊंचाई का beeper का एक टॉवर है, हालांकि कुछ कॉलम (जैसे कि 7 वें, और नमूना दुनिया में 9 वें) खाली हो सकते हैं। करेल का काम इन सभी टावरों में से सभी beeper एस को इकट्ठा करना है, उन्हें पहली पंक्ति के सबसे पूर्वी कोने पर वापस रखना है, और फिर अपनी शुरुआती स्थिति में वापस आना है। इस प्रकार, जब करेल ऊपर के उदाहरण में अपना काम पूरा कर रहे हैं, वर्तमान में सभी 25 beeper एस टावरों को 9 वें स्तंभ और पहली पंक्ति के कोने पर स्टैक्ड किया जाना चाहिए, इस प्रकार है:</p>





<div class="section" id="world2">
<div class="ide getStarted" id="world2Ide">
<div class="commandCanvasDiv" id="world2CanvasDiv">
<div>
<div class="commandCanvasOuter">
<canvas id="world2Canvas" style="width:400px;"></canvas>
</div>
</div>
</div>
</div>
<script>

        

function exampleworld2() {
 var karelIde = null;
 var buttonState = 'play';
 var canvas = null;

 function main() {
    canvas = document.getElementById('world2Canvas');
    karelIde = KarelIde('java',null, canvas, 'beeperTowersGoal', 0, 'hi',1000, 0.8 * 1000);
 }

 
 main()
 
}
exampleworld2();
    </script>
</div>

<p>महत्वपूर्ण बात, आप मान सकते हैं कि करेल प्रारंभिक<i>शुरू होता है</i>अपने बैग में शून्य beeper एस के साथ। प्रत्येक beeper उठाया गया बैग उसके बैग में जोड़ा जाता है। जब डाल beeper कोने में है, कैरेल उपयोग कर सकते हैं <code>beepersInBag()</code> परीक्षा।</p>
<p>इस समस्या को हल करने की कुंजी कार्यक्रम को सही तरीके से विघटित करना है, जबकि आप अभी भी परीक्षण करने में सक्षम हैं। यह कार्य आपके द्वारा देखे गए अन्य की तुलना में अधिक जटिल है, जो एक सफल समाधान प्राप्त करने के लिए उचित उपप्रकारों को चुनना अधिक महत्वपूर्ण बनाता है।</p>
<h3>टॉप-डाउन डिज़ाइन का सिद्धांत</h3>
<p>स्टेप वाइज शोधन में मुख्य विचार यह है कि आपको अपने कार्यक्रम का डिज़ाइन ऊपर से शुरू करना चाहिए, जो उस कार्यक्रम के स्तर को संदर्भित करता है जो वैचारिक रूप से उच्चतम और सबसे अधिक सार है। इस स्तर पर, beeper टॉवर समस्या स्पष्ट रूप से तीन स्वतंत्र चरणों में विभाजित है। सबसे पहले, कारेल को सभी beeper एस को इकट्ठा करना है। दूसरा, कारेल को उन्हें आखिरी चौराहे पर जमा करना होगा। तीसरा, कारेल को अपने घरेलू स्थान पर लौटना होगा। समस्या के इस अवधारणात्मक अपघटन से पता चलता है कि इस कार्यक्रम के लिए run विधि में निम्नलिखित संरचना होगी:</p>
<p class="demoCode" style="margin-left:10px">
 <code>   <span class="keyword">public void</span> run() {</code> <br/>
 <code>      सभीConoएसएकत्रकरें();</code> <br/>
 <code>      सभीConoएसड्रॉपकरें();</code> <br/>
 <code>      घरलौटना();</code> <br/>
 <code>   }</code> <br/>
</p>
<p>इस स्तर पर, समस्या को समझना आसान है। बेशक, कुछ विवरण ऐसे तरीकों के रूप में बचे हैं जिन्हें आपने अभी तक नहीं लिखा है। फिर भी, अपघटन के प्रत्येक स्तर को देखना और अपने आप को यह समझाना ज़रूरी है कि, जब तक आप मानते हैं कि आपके द्वारा लिखी जाने वाली विधियाँ उपप्रकारों को सही ढंग से हल कर देंगी, तब आपके पास समस्या का समाधान पूरी तरह से होगा। ।</p>
<h3>जैसे ही आप जाते हैं Iterative परीक्षण</h3>
<p>अब जब आपने कार्यक्रम के लिए संरचना को एक पूरे के रूप में परिभाषित किया है, तो यह पहला move करने के लिए move का समय है, जिसमें सभी beeper एस एकत्रित होते हैं। यह कार्य पूर्ववर्ती अध्यायों की सरल समस्याओं की तुलना में अधिक जटिल है। सभी beeper एस को इकट्ठा करने का मतलब है कि आपको हर टॉवर में beeper एस को उठाना होगा जब तक आप अंतिम कोने तक नहीं पहुंच जाते। तथ्य यह है कि आपको प्रत्येक टॉवर के लिए एक ऑपरेशन को दोहराने की आवश्यकता है जो बताता है कि आपको यहां थोड़ी देर की आवश्यकता है। जबकि लूप की प्रक्रिया दोहराएगी <code>एकटावरइकट्ठाकरो</code> और फिर चल रहा है।</p>
<p> <b>सावधान:</b> इसके बिना पूरे कार्यक्रम को लिखने की कोशिश करना खतरनाक है <b>परिक्षण</b> जैसे तुम जाओ। यदि आप एक गलती करते हैं तो गलती खोजना मुश्किल होगा। हम जानते हैं कि हम एक टॉवर को इकट्ठा करने की प्रक्रिया को दोहराने जा रहे हैं। हमें लिखें और <b>परीक्षा</b> इससे पहले कि हम डाल एक एकल टॉवर का संग्रह <code>एकटावरइकट्ठाकरो</code> लूप के लिए प्रक्रिया। इस प्रकार<i>temporariliy</i>हम सभी कॉनो एसएक्रत्रकर की निम्नलिखित परिभाषा के साथ शुरू कर सकते हैं:<p class="demoCode" style="margin-left:10px">
 <code>   <span class="keyword">private void</span> सभीConoएसएकत्रकरें() {</code> <br/>
 <code class="comment">      /* परीक्षण प्रयोजनों के लिए अस्थायी कार्यान्वयन */</code> <br/>
 <code>      एकटावरइकट्ठाकरो();</code> <br/>
 <code>      move();</code> <br/>
 <code>   }</code> <br/>
</p>
<p>एक मार्गदर्शक सिद्धांत के रूप में, यदि आपके पास एक जटिल लूप है, तो परीक्षण करें<i>तन</i>लूप से पहले आप पूरा लूप लिखें।</p>
<h3>रिफाइनिंग कलेक्शन टॉवर</h3>
<p>जब वनताराइकट्ठाकरो को बुलाया जाता है, तो करेल या तो beeper टॉवर के आधार पर खड़ा होता है या खाली कोने पर खड़ा होता है। पूर्व मामले में, आपको टॉवर में beeper एस को इकट्ठा करने की आवश्यकता है। उत्तरार्द्ध में, आप बस move पर कर सकते हैं। यह स्थिति इफ स्टेटमेंट के लिए एक एप्लिकेशन की तरह लगती है, जिसमें आप कुछ इस तरह से लिखते हैं:</p>
<p class="demoCode" style="margin-left:10px">
 <code>   <span class="keyword">if</span>(beepersPresent()){</code> <br/>
 <code>      वास्तविकटॉवरइकट्ठा();</code> <br/>
 <code>   }</code> <br/>
</p>
<p>इससे पहले कि आप इस तरह के बयान को कोड में शामिल करें, आपको यह सोचना चाहिए कि क्या आपको यह परीक्षण करने की आवश्यकता है। अक्सर, कार्यक्रमों को यह देखते हुए बहुत सरल बनाया जा सकता है कि पहली बार में विशेष लगने वाले मामलों को ठीक उसी तरह से व्यवहार किया जा सकता है जैसे कि सामान्य स्थिति। वर्तमान समस्या में, यदि आप यह तय करते हैं कि प्रत्येक एवेन्यू पर beeper टॉवर है, लेकिन क्या होता है, तो उनमें से कुछ टॉवर शून्य beeper उच्च हैं? इस अंतर्दृष्टि का उपयोग करने से कार्यक्रम सरल हो जाता है क्योंकि अब आपको यह परीक्षण नहीं करना है कि किसी विशेष एवेन्यू पर एक टॉवर है या नहीं।</p>
<p>एकटावराइकट्ठाकरो विधि अभी भी पर्याप्त जटिल है कि अपघटन का एक अतिरिक्त स्तर क्रम में है। एक टॉवर में सभी beeper एस को इकट्ठा करने के लिए, कारेल को निम्नलिखित कदम उठाने की आवश्यकता है:</p>
<ol>
<li>टॉवर में beeper का सामना करने के लिए बाएं मुड़ें।<li>टॉवर में सभी beeper एस लीजिए, जब कोई और अधिक beeper एस नहीं पाए जाते हैं।<li>दुनिया के नीचे की ओर वापस मुड़ने के लिए मुड़ें।<li>जमीन का प्रतिनिधित्व करने वाली दीवार पर लौटें।<li>अगले कोने में move पर तैयार होने के लिए बाएं मुड़ें।</li></li></li></li></li></ol>
<p>एक बार फिर, यह रूपरेखा एकटावराइकट्ठाकरो विधि के लिए एक मॉडल प्रदान करती है, जो इस तरह दिखता है:</p>
<p class="demoCode" style="margin-left:10px">
 <code>   <span class="keyword">private void </span>एकटावरइकट्ठाकरो(){</code> <br/>
 <code>      turnLeft();</code> <br/>
 <code>      conoएसकीलाइनइकट्ठा();</code> <br/>
 <code>      turnAround();</code> <br/>
 <code>      moveदीवारकेलिए();</code> <br/>
 <code>      turnLeft();</code> <br/>
 <code>   }</code> <br/>
</p>
<h3>विधि पूर्व शर्त और पोस्टकंडिशन</h3>
<p>इस कार्यक्रम की शुद्धता के लिए एकटवराइकट्ठाकरो विधि की शुरुआत और अंत में ब्यूमुर्डिएक कमांड दोनों महत्वपूर्ण हैं। जब वनताराइकट्ठाकरो कहा जाता है, तो करेल हमेशा 1 पंक्ति पर होता है जो पूर्व की ओर है। जब यह अपना ऑपरेशन पूरा कर लेता है, तो समग्र रूप से प्रोग्राम तभी सही ढंग से काम करेगा, जब कारेल फिर से उसी कोने पर पूर्व की ओर मुंह कर रहा हो। किसी विधि को कॉल करने से पहले सत्य होने वाली शर्तों को कहा जाता है <b>पूर्व शर्त</b> ; विधि समाप्त होने के बाद लागू होने वाली शर्तों को इस रूप में जाना जाता है <b>postconditions</b> ।</p>
<p>जब आप किसी विधि को परिभाषित करते हैं, तो आप ठीक से कम परेशानी में पड़ जाएंगे यदि आप ठीक-ठीक लिखते हैं कि पूर्व और पश्चात क्या हैं। एक बार जब आप ऐसा कर लेते हैं, तो आपको यह सुनिश्चित करने की आवश्यकता होती है कि आप जो कोड लिखते हैं वह हमेशा पोस्टकंडिशन को संतुष्ट करता है, यह मानते हुए कि पूर्व शर्त के साथ शुरू करने के लिए संतुष्ट थे। उदाहरण के लिए, यह सोचें कि क्या होता है जब आप एकटावराइकट्ठाकरो को बुलाते हैं, जब करेल पहली पंक्ति में पूर्व की ओर है। पहले BandAmouriac कमांड ने कारेल का उत्तर की ओर मुंह किया, जिसका अर्थ है कि कैरेल टॉवर के प्रतिनिधित्व वाले beeper कॉलम के साथ ठीक से जुड़ा हुआ है। कोनो एसकीलाइनाइकट्ठा विधि — जिस पर लिखा जाना अभी बाकी है, लेकिन फिर भी एक ऐसा कार्य करता है जिसे आप वैचारिक रूप से समझते move केवल move बिना मोड़ के। इस प्रकार, एस.ओ. क्लाइनिनकट्ठा कोनो को कॉल के अंत में, कारेल अभी भी उत्तर की ओर मुंह करेगा। टर्नो कॉल इसलिए कारेल को दक्षिण की ओर मुंह करता है। कॉनो एसकीलाइनाइकट्ठा की तरह, move वालकिया विधि में कोई भी मोड़ शामिल नहीं है, लेकिन इसके बजाय केवल move एस जब तक यह सीमा की दीवार को हिट नहीं करता है। क्योंकि कारेल दक्षिण की ओर है, यह बाउंड्री वॉल स्क्रीन के निचले भाग में पहली पंक्ति के नीचे एक होगी। अंतिम BandAmourIVE कमांड इसलिए कर्ल को पूर्व की ओर पहली पंक्ति पर छोड़ता है, जो पोस्टकंडिशन को संतुष्ट करता है।</p>
<h3>प्रक्रिया को दोहराते हुए</h3>
<p>आप अपने कार्यक्रम को run करते हैं और यह सफलतापूर्वक एक टॉवर को साफ करता है और करेल को प्रस्तावित पोस्टकांड में छोड़ देता है। वाहू! आपने इस कठिन कार्य को सुलझाने में एक मील का पत्थर मारा है! अब हमें थोड़ी सी लूप का उपयोग करके एक टॉवर को साफ करने की प्रक्रिया को दोहराना होगा।</p>
<p>लेकिन यह क्या करता है जबकि लूप दिखता है? सबसे पहले, आपको सशर्त परीक्षण के बारे में सोचना चाहिए। आप चाहते हैं कि जब यह पंक्ति के अंत में दीवार से टकराए तो कैरेल बंद हो जाए। इस प्रकार, आप चाहते हैं कि कारेल तब तक चलते रहें जब तक सामने का स्थान स्पष्ट न हो जाए। इस प्रकार, आप जानते हैं कि सभी कोनो एसएक्रत्रकरें पद्धति में एक लूप शामिल होगा जो कि फ्रंटस्पर्टहै परीक्षण का उपयोग करता है। प्रत्येक स्थिति में, आप चाहते हैं कि कारेल उस कोने पर शुरू होने वाले टॉवर में सभी beeper एस को इकट्ठा करे। यदि आप उस ऑपरेशन को एक नाम देते हैं, जो एकटवराइकट्ठाकरो की तरह कुछ हो सकता है, तो आप आगे जा सकते हैं और सभी कॉनो एसएक्रत्रकरें विधि के लिए एक परिभाषा लिख सकते हैं, भले ही आप अभी तक विवरण में नहीं भरे हैं।</p>
<p>हालाँकि, आपको सावधान रहना होगा। सभी कोनो सक्रत्रकारों के लिए कोड इस तरह नहीं दिखता है:</p>
<p class="demoCode" style="margin-left:10px">
 <code>   <span class="keyword">private void </span>सभीConoएसएकत्रकरें(){</code> <br/>
 <code class="comment">      /* छोटी गाड़ी लूप! */</code> <br/>
 <code>      <span class="keyword">while</span>(frontIsClear()) {</code> <br/>
 <code>         एकटावरइकट्ठाकरो();</code> <br/>
 <code>         move();</code> <br/>
 <code>      }</code> <br/>
 <code>   }</code> <br/>
</p>
<p>यह कार्यान्वयन ठीक उसी कारण से छोटा है, जब अध्याय 6 से सामान्य प्लेसकोनो लाइन का पहला संस्करण अपना काम करने में विफल रहा। कोड के इस संस्करण में एक फ़र्स्टपोस्ट त्रुटि है, क्योंकि कारेल को आखिरी एवेन्यू पर beeper टॉवर की उपस्थिति के लिए परीक्षण करने की आवश्यकता है। सही कार्यान्वयन है:</p>
<p class="demoCode" style="margin-left:10px">
 <code>   <span class="keyword">private void </span>सभीConoएसएकत्रकरें(){</code> <br/>
 <code>      <span class="keyword">while</span>(frontIsClear()) {</code> <br/>
 <code>         एकटावरइकट्ठाकरो();</code> <br/>
 <code>         move();</code> <br/>
 <code>      }</code> <br/>
 <code>      एकटावरइकट्ठाकरो();</code> <br/>
 <code>   }</code> <br/>
</p>
<p>ध्यान दें कि इस विधि में ठीक वैसा ही ढांचा है जैसा कि चैप्टर 6. में प्रस्तुत प्लेकोनो लाइन कार्यक्रम के मुख्य कार्यक्रम का है। फर्क सिर्फ इतना है कि यह प्रोग्राम एकटावराइकट्ठाकरो को कॉल करता है जहां दूसरा बीपरचिपो कहलाता है। ये दो कार्यक्रम एक सामान्य रणनीति के प्रत्येक उदाहरण हैं जो इस तरह दिखता है:</p>
<p class="demoCode" style="margin-left:10px">
 <code>   <span class="keyword">private void </span>सभीConoएसएकत्रकरें(){</code> <br/>
 <code>      <span class="keyword">while</span>(frontIsClear()) {</code> <br/>
 <code>         </code> <i class="demoText">कुछ ऑपरेशन करें।</i><br/>
 <code>         move();</code> <br/>
 <code>      }</code> <br/>
 <code>      </code> <i class="demoText">अंतिम कोने के लिए एक ही ऑपरेशन करें।</i><br/>
 <code>   }</code> <br/>
</p>
<p>आप इस रणनीति का उपयोग तब कर सकते हैं जब आपको हर कोने पर एक ऑपरेशन करने की आवश्यकता होती है क्योंकि आप एक दीवार पर समाप्त होने वाले रास्ते के साथ move । यदि आपको इस रणनीति की सामान्य संरचना याद है, तो जब भी आपको ऐसी समस्या का सामना करना पड़ता है, तो आप इसका इस्तेमाल कर सकते हैं। इस तरह की पुन: प्रयोज्य रणनीति प्रोग्रामिंग में अक्सर आती है और इसे संदर्भित किया जाता है <b>प्रोग्रामिंग मुहावरे</b> या <b>पैटर्न</b> । जितने अधिक पैटर्न आप जानते हैं, उतना ही आपके लिए यह आसान होगा कि आप किसी विशेष प्रकार की समस्या को हल करें।</p>
<h3>पूरी तरह खत्म करना</h3>
<p>हालांकि कड़ी मेहनत की गई है, फिर भी कई ढीले छोर हैं जिन्हें हल करने की आवश्यकता है। मुख्य कार्यक्रम दो तरीकों को बुलाता है- सभी कॉनो एसड्रॉपकर और होमलॉइट- जो अभी तक अलिखित हैं। इसी तरह, एकतवाराइकट्ठाकरो कोनो एसकीलाइनाइकट्ठा और move वाल्किएक कहते हैं। सौभाग्य से, इन तरीकों के सभी चार, किसी भी आगे अपघटन के बिना कोड के लिए काफी सरल कर रहे हैं विशेष रूप से अगर आप का उपयोग move घरलौटना की परिभाषा में दीवारकेलिए। यहाँ पूरा कार्यान्वयन है:</p>






<div class="section embeddedIde" id="beeperTowers">
<div class="ide getStarted" id="beeperTowersIde" style="height:1702.3500000000001px">
<div class="ideCenter" id="beeperTowersIdeCenter" style="height:inherit;">
<div id="beeperTowersEditorDiv" style="width:600px;height:inherit;"></div>
</div>
</div>
<div id="beeperTowersCanvasDiv" style="width:500px;height:360px">
<canvas class="ideCanvas" id="beeperTowersCanvas"></canvas>
</div>
<div style="width:100%;">
<div class="buttonBar">
<button class="btn btn-default" id="beeperTowersRunButton"><span class="glyphicon glyphicon-play"></span>प्रोग्राम चलाओ</button>
</div>
</div>
<script>

        

function examplebeeperTowers() {
STARTER_CODE = `

/*
 * फ़ाइल: कॉनो संग्रह। जावा
 * -----------------------
 * कोनो beeper क्लास सभी beeper एस को खड़ी टावरों की
 * एक श्रृंखला में इकट्ठा करता है और उन्हें पहली पंक्
 * ति में सबसे पूर्वी कोने में जमा करता है।
 */
import stanford.कैरेल.*;
public class Conoसंग्रह extends कैरेल {

   /**
    * कार्यक्रम प्रविष्टि बिंदु निर्दिष्ट करता है।
    */
   public void run() {
      सभीConoएसएकत्रकरें();
      सभीConoएसड्रॉपकरें();
      घरलौटना();
   }

   /**
    * 1 पंक्ति के साथ हर टॉवर से beeper इकट्ठा करता है,
    * हर कोने पर एकटावराइकटहाकारो को बुलाता है। इस विधि
    * के लिए उत्तरार्ध यह है कि कारेल 1 पंक्ति के सबसे प
    * ूर्वी कोने में पूर्व की ओर है।
    */
   private void सभीConoएसएकत्रकरें() {
      while (frontIsClear()) {
         एकटावरइकट्ठाकरो();
         move(); 
      }
      एकटावरइकट्ठाकरो();
   }

   /**
    * एक ही टावर में beeper एस एकत्र करता है। जब वनताराइ
    * कट्ठाकरो को बुलाया जाता है, तो कारेल पूर्व की ओर प
    * हली पंक्ति में होना चाहिए। वनतारविकट्ठाकरो के लिए
    * पदावनति यह है कि कारेल को फिर से उसी कोने पर पूर्व
    * की ओर मुंह करना होगा।
    */
   private void एकटावरइकट्ठाकरो() {
      turnLeft();
      conoएसकीलाइनइकट्ठा();
      turnAround();
      moveदीवारकेलिए();
      turnLeft();
   }

   /**
    * beeper एस की एक निरंतर रेखा एकत्र करता है। beeper
    * लाइन का अंत एक कोने से दर्शाया गया है जिसमें beepe
    * r s नहीं है।
    */
   private void conoएसकीलाइनइकट्ठा() {
      while (beepersPresent()) {
         pickBeeper();
         if (frontIsClear()) {
            move(); 
         }
      } 
   }

   /**
    * वर्तमान कोने पर सभी beeper एस को beeper ।
    */
   private void सभीConoएसड्रॉपकरें() {
      while (beepersInBag()) {
         putBeeper();
      }
   }

   /**
    * पूरब की ओर, पहले एवेन्यू और पहली पंक्ति के कोने पर
    * कारेल को अपनी प्रारंभिक स्थिति में लौटाता है। इस
    * पद्धति के लिए पूर्व शर्त यह है कि कारेल को पहली पं
    * क्ति में कहीं पर पूर्व की ओर मुंह करना होगा, जो सभ
    * ी कॉनो सिकरकारें के निष्कर्ष पर सही है।
    */
   private void घरलौटना() {
      turnAround();
      moveदीवारकेलिए();
      turnAround();
   }

   /** करेल को तब तक आगे बढ़ाता है जब तक कि यह एक दीवार से अवरुद्ध न हो जाए। */
   private void moveदीवारकेलिए(){
      while (frontIsClear()) {
         move();
      } 
   }

   /** करेल 180 डिग्री के आसपास घूमता है */
   private void turnAround(){
      turnLeft();
      turnLeft();
   }
}
`
// because of that extra endline at the start of the string
STARTER_CODE = STARTER_CODE.trim();

 var karelIde = null;
 var karelEditor = null;
 var buttonState = 'play';

 function main() {
   karelEditor = importEditorCode('beeperTowersEditor','beeperTowersEditorDiv', STARTER_CODE, false);
     //importRunButtonBar('example1ButtonBar');
    
    $("[title]").tooltip({ position: "bottom center", opacity: 0.9});
    
    initTabs();
    var canvas = document.getElementById('beeperTowersCanvas');
    karelIde = KarelIde('java',karelEditor, canvas, 'beeperTowers', 0.9, 'hi', 1000, 
      0.8 * 1000);
    $('#beeperTowersRunButton').click(function(){playClicked()});
    onresize();
 }

 function playClicked() {
  if(buttonState == 'play') {
    karelIde.playButton();
      
      var resetText = '<span class="glyphicon glyphicon-repeat"></span> Reset Program';
      $('#beeperTowersRunButton').html(resetText);
      buttonState = 'reset';
     } else if (buttonState == 'reset') {
      karelIde.stopButton();
      var playText = '<span class="glyphicon glyphicon-play"></span> Run Program';
      $('#beeperTowersRunButton').html(playText);
      buttonState = 'play';
     }
    
  }

  function onresize() { 

    // var parentHeight = 1702.3500000000001;
    // var canvasWidth = 300
    // var parentWidth = $("#beeperTowers").width();
    // console.log('pw: ' + parentWidth);

    // var editorDiv = document.getElementById('beeperTowersCanvasDiv');
    // var canvas = document.getElementById('beeperTowersCanvas');
    


    // var availibleWidth = parentWidth;
    // var elementSpacing = 12;

    // var editorWidth = availibleWidth - canvasWidth - elementSpacing; 

    // canvas.style.width = canvasWidth + 'px';
    // canvas.style.height = canvasWidth + 'px';
    // canvas.style.left = (editorWidth + elementSpacing) + 'px';
 }

 
 main()
 
}
examplebeeperTowers();
    </script>
</div>

</p><hr/>
<center>
<a class="btn btn-primary btn-lg" href="chapter9.html" role="button">अगला अध्याय</a> 
</center>




<div style="height:60px"></div>
</div>
</div>
</div>
<!-- right gutter -->
<div style="flex-grow:4"></div>
</div>
</div>
</body>
</html>
