<html><head>
<title> Leitor Karel </title><meta content="text/html; charset=utf-8" http-equiv="Content-Type"/><script src="../plugins/jquery.min.js"></script><link href="../plugins/bootstrap/css/bootstrap.min.css" rel="stylesheet"/><script src="../plugins/bootstrap/js/bootstrap.min.js"></script><link href="../style.css" rel="stylesheet"/><script src="..//karel/js/html/websiteImports.js"></script><script>importCss();</script><script>importJs();</script></head><body><!-- container --><div class="bookContainer">
<!-- side bar --><div class="bookSideBar"><div class="homeLink"><a href="http://cs106a.stanford.edu"><span aria-hidden="true" class="glyphicon glyphicon-home"></span> CS106A</a></div><hr/><div class="sideBarTitle"><a href="../pt/intro.html" style="color:black">Leitor Karel</a></div><div class="chapterTab"><a class="bookLink btn btn-link" href="../pt/chapter1.html">1 - Conheça Karel</a></div><div class="chapterTab"><a class="bookLink btn btn-link" href="../pt/chapter2.html">2 - Programação</a></div><div class="chapterTab"><a class="bookLink btn btn-link" href="../pt/chapter3.html">3 - Novos Métodos</a></div><div class="chapterTab"><a class="bookLink btn btn-link" href="../pt/chapter4.html">4 - Decomposição</a></div><div class="chapterTab"><a class="bookLink btn btn-link" href="../pt/chapter5.html">5 - For Loops</a></div><div class="chapterTab"><a class="bookLink btn btn-link" href="../pt/chapter6.html">6 - While Loops</a></div><div class="chapterTab"><a class="bookLink btn btn-link" href="../pt/chapter7.html">7 - Condicionais</a></div><div class="chapterTab"><a class="bookLink btn btn-link" href="../pt/chapter8.html">8 - Refinamento</a></div><div class="chapterTab"><a class="bookLink btn btn-link" href="../pt/chapter9.html">9 - Algoritmos</a></div><div class="chapterTab"><a class="bookLink btn btn-link" href="../pt/chapter10.html">10 - SuperKarel</a></div><!-- <center>
    <img style ="width:75px;" src="../images/stanford.png"/>
    </center>--></div><!-- content --><div class="bookContent" style="display: flex;"><!-- right gutter --><div style="flex-grow:1; flex-basis:50px; max-width:50px"></div><!-- main stuff --><div class="" style="flex-basis:740px; max-width:740px; margin-left:20px; margin-right:20px; "><div class="row"><div class="col-md-12 col-xs-12">

<h1> Capítulo 2: Programação Karel </h1><hr/><p> O estilo mais simples do programa Karel usa texto para especificar uma sequência de comandos internos que devem ser executados quando o programa é <b>executado</b>. Considere o programa simples de Karel abaixo. O texto à esquerda é o programa. O estado do mundo de Karel é mostrado à direita: </p>



<div class="section embeddedIde" id="beeperPicking"><div class="ide getStarted" id="beeperPickingIde" style="height:299.20000000000005px"><div class="ideCenter" id="beeperPickingIdeCenter"><div class="ideEditorDiv" id="beeperPickingEditorDiv" style="width:200px"></div><div class="ideCanvasDiv" id="beeperPickingCanvasDiv"><canvas class="ideCanvas" id="beeperPickingCanvas"></canvas></div></div></div><div style="width:100%;"><div class="buttonBar"><button class="btn btn-default" id="beeperPickingRunButton"><span class="glyphicon glyphicon-play"></span> Rodar programa</button></div></div><script>

        

function examplebeeperPicking() {
STARTER_CODE = `

/*
 * Ficheiro: BeeperPickingKarel.java
 * ---------------------------------
 * O programa BeeperPickingKarel define um método
 * "run" com três comandos. Esses comandos fazem com
 * que Karel avance um bloco, pegue um bip e avance
 * para o próximo canto.
 */
import stanford.karel.*;
public class BeeperPickingKarel extends Karel {
   /* o programa começa a correr aqui */
   public void run() {
      mover();
      escolherBeeper();
      mover();
   } 
}
`
// because of that extra endline at the start of the string
STARTER_CODE = STARTER_CODE.trim();

 var karelIde = null;
 var karelEditor = null;
 var buttonState = 'play';

 function main() {
   karelEditor = importEditorCode('beeperPickingEditor','beeperPickingEditorDiv', STARTER_CODE, false);
     //importRunButtonBar('example1ButtonBar');
    
    $("[title]").tooltip({ position: "bottom center", opacity: 0.9});
    
    initTabs();
    var canvas = document.getElementById('beeperPickingCanvas');
    karelIde = KarelIde(karelEditor, canvas, 'stepUp', 0.0);
    $('#beeperPickingRunButton').click(function(){playClicked()});
    onresize();
    
 }

 function playClicked() {
  if(buttonState == 'play') {
    karelIde.playButton();
      
      var resetText = '<span class="glyphicon glyphicon-repeat"></span> Reset Program';
      $('#beeperPickingRunButton').html(resetText);
      buttonState = 'reset';
     } else if (buttonState == 'reset') {
      karelIde.stopButton();
      var playText = '<span class="glyphicon glyphicon-play"></span> Run Program';
      $('#beeperPickingRunButton').html(playText);
      buttonState = 'play';
     }
  
  }

 function onresize() { 
    var parentHeight = 299.20000000000005;
    var canvasWidth = 300
    var parentWidth = $("#beeperPicking").width();
    console.log('pw: ' + parentWidth);

    var ide = document.getElementById('beeperPickingIde');
    var editorDiv = document.getElementById('beeperPickingEditorDiv');
    var canvas = document.getElementById('beeperPickingCanvasDiv');
    
    var ideHeight = parentHeight
    var centerHeight = ideHeight;

    var availibleWidth = parentWidth;
    var elementSpacing = 12;

    var editorWidth = availibleWidth - canvasWidth - elementSpacing; 

    canvas.style.width = canvasWidth + 'px';
    canvas.style.height = canvasWidth + 'px';
    canvas.style.left = (editorWidth + elementSpacing) + 'px';



    editorDiv.style.left = 0 + 'px'
    editorDiv.style.width = editorWidth + 'px';
    editorDiv.style.height = parentHeight + 'px';
    console.log('editor width: ' + editorWidth)

    if (karelEditor) {
       karelEditor.renderer.onResize();
    }
 }
 main()
 
}
examplebeeperPicking();
    </script></div>
<p> Pressione o botão &quot;Executar&quot; para executar o programa. Os programas geralmente são escritos em um aplicativo especial chamado <b>Ambiente de Desenvolvimento Integrado</b>(IDE) e a maioria dos programas Karel são escritos em um IDE chamado Eclipse. Como um IDE, esse leitor tem a capacidade de executar programas para ajudá-lo a <i>ver</i> como as coisas funcionam à medida que você aprende. </p><p> O programa é composto de várias partes. A primeira parte consiste nas seguintes linhas: </p><p><p class="demoCode" style="margin-left:10px"><pre class="comment" translate="no">/*
&nbsp;*&nbsp;Ficheiro: BeeperPickingKarel.java
&nbsp;* ---------------------------------
&nbsp;*&nbsp;O programa BeeperPickingKarel define um método
&nbsp;* "run" com três comandos. Esses comandos fazem com
&nbsp;* que Karel avance um bloco, pegue um bip e avance
&nbsp;* para o próximo canto.
&nbsp;*/</pre></p><p> Essas linhas são um exemplo de um <b>comentário</b>, que é simplesmente um texto projetado para explicar o funcionamento do programa aos leitores humanos. Comentários em Karel e Java começam com os caracteres <code class="comment">/*</code> e terminam com os caracteres <code class="comment">*/</code>. Aqui, o comentário começa na primeira linha e termina várias linhas depois. As estrelas nas linhas individuais que compõem o texto do comentário não são necessárias, mas tornam mais fácil para os leitores humanos verem a extensão do comentário. Em um programa simples, comentários extensos podem parecer tolos porque o efeito do programa é óbvio, mas eles são extremamente importantes como um meio de documentar o design de programas maiores e mais complexos. A segunda parte do programa é a linha: </p><p class="demoCode" style="margin-left:10px"><code><span class="keyword">import</span> stanford.karel.*;</code></p><p> Esta linha solicita a inclusão de todas as definições da biblioteca <code>stanford.karel</code>. Esta biblioteca contém as definições básicas necessárias para escrever programas Karel, como as definições das operações padrão <code>mover()</code> e <code>escolherBeeper()</code>. Como você sempre precisa acessar essas operações, todo programa Karel que você escrever incluirá esse comando de importação antes de você escrever o programa real. </p><p> A parte final do programa Karel consiste na seguinte definição de programa: </p><p class="demoCode" style="margin-left:10px"><code><span class="keyword">public class</span> BeeperPickingKarel <span class="keyword">extends</span> Karel {</code><br/><code>&nbsp;&nbsp;&nbsp;<span class="keyword">public void</span> run() {</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mover();</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;escolherBeeper();</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mover();</code><br/><code>&nbsp;&nbsp;&nbsp;}</code><br/><code>}</code><br/></p><p> Para entender essa definição, é útil observar com mais cuidado sua estrutura. A definição do programa BeeperPickingKarel consiste na linha que começa com <code class="keyword">public class</code> e engloba tudo entre a chave no final da linha e a chave de fechamento correspondente na última linha do programa. A única linha que introduz a nova classe é chamada de <b>cabeçalho</b> da definição; o código entre as chaves é chamado de <b>corpo</b>. </p><p> Na programação, muitas vezes é muito útil pensar em uma definição particular e seu corpo como idéias separáveis. Neste exemplo, a definição de BeeperPickingKarel tem o seguinte formato, onde o corpo inteiro da definição pode ser colocado fora da sua mente no momento: </p><p class="demoCode" style="margin-left:10px"><code><span class="keyword">public class</span> BeeperPickingKarel <span class="keyword">extends</span> Karel {</code><br/><i class="demoText" style="margin-left:2em">corpo da definição do programa</i><br/><code>}</code><br/></p><p> A linha de cabeçalho no topo diz muito sobre o programa BeeperPickingKarel, mesmo antes de você ter olhado para ver o que o corpo contém. A frase <code class="keyword">public class</code> inicia a definição de um programa. A frase <code><span class="keyword">extends</span> Karel</code> é usado para indicar que o <code>BeeperPickingKarel</code> é um programa da Karel. </p><p> Agora vamos ver o corpo do programa BeeperPickingKarel. Esse corpo consiste nas seguintes linhas: </p><p class="demoCode" style="margin-left:10px"><code>&nbsp;&nbsp;&nbsp;<span class="keyword">public void</span> run() {</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mover();</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;escolherBeeper();</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mover();</code><br/><code>&nbsp;&nbsp;&nbsp;}</code><br/></p><p> Essas linhas representam a definição de um novo <b>método</b>, que especifica a seqüência de etapas necessárias para responder a um comando. Como no caso do próprio programa BeeperPickingKarel, a definição do método consiste em duas partes que podem ser consideradas separadamente: A primeira linha constitui o cabeçalho do método e o código entre as chaves é o corpo do método. Se você ignorar o corpo por enquanto, a definição do método será assim: </p><p class="demoCode" style="margin-left:10px"><code>&nbsp;&nbsp;&nbsp;<span class="keyword">public void</span> run() {</code><br/><i class="demoText" style="margin-left:3.5em">corpo da definição do método</i><br/><code>&nbsp;&nbsp;&nbsp;}</code><br/></p><p> As duas primeiras palavras no cabeçalho do método, <code class="keyword">public</code> e <code class="keyword">void</code>, fazem parte da estrutura sintática do Java, e você deve se sentir livre para ignorá-las neste momento. A próxima palavra na linha de cabeçalho especifica o nome do novo método, que neste caso é o método <b>executado</b>. Definir um método significa que Karel agora pode responder a um novo comando com esse nome. O comando <code>run</code> desempenha um papel especial em um programa Karel. Quando você inicia um programa Karel, ele cria uma nova instância Karel, adiciona esse Karel a um mundo que você especifica e, em seguida, emite o comando run. O efeito de executar o programa é definido pelo corpo do método de execução, que é uma sequência de comandos que o robô executará em ordem. Por exemplo, o corpo do método de execução do programa BeeperPickingKarel é: </p><p class="demoCode" style="margin-left:10px"><code>&nbsp;&nbsp;&nbsp;mover();</code><br/><code>&nbsp;&nbsp;&nbsp;escolherBeeper();</code><br/><code>&nbsp;&nbsp;&nbsp;mover();</code><br/></p><p> Assim, se o estado inicial do mundo coincide com o exemplo dado no Capítulo 1, Karel primeiro avança para o canto contendo o sinal sonoro, pega o bip e, finalmente, avança para o canto imediatamente antes da parede, como mostrado a seguir. diagrama antes e depois: </p>


<div class="section" id="ba2"><div class="ide getStarted" id="ba2Ide"><div class="commandCanvasDiv" id="ba2CanvasDiv"><div><div class="commandCanvasTitle"> Antes: </div><div class="commandCanvasOuter"><canvas id="ba2CanvasBefore" style="width:300px;"></canvas></div></div><div style="width:50px"></div><div><div class="commandCanvasTitle"> Depois de: </div><div class="commandCanvasOuter"><canvas id="ba2CanvasAfter" style="width:300px;"></canvas></div></div></div></div><script>

        

function exampleba2() {
 var karelIde = null;
 var buttonState = 'play';
 var canvas = null;

 function main() {
    canvas = document.getElementById('ba2CanvasBefore');
    karelIde = KarelIde(null, canvas, 'stepUp', 0.0, 1000, 0.7 * 1000);

    let canvasGoal = document.getElementById('ba2CanvasAfter');
    let goalIde = KarelIde(null, canvasGoal, 'stepUpM1',0.0,  1000, 0.7 * 1000)
 }

 
 main()
 
}
exampleba2();
    </script></div><h2> Resolvendo um problema mais interessante </h2><p> O programa BeeperPickingKarel definido acima não faz muito ainda. Vamos tentar torná-lo um pouco mais interessante. Suponha que o objetivo não seja simplesmente fazer com que Karel pegue o beeper, mas mova o beeper de sua posição inicial na segunda coluna e primeira linha para o centro de uma saliência. Assim, sua próxima tarefa é definir um novo programa Karel que realize a tarefa ilustrada neste diagrama: </p>


<div class="section" id="ba3"><div class="ide getStarted" id="ba3Ide"><div class="commandCanvasDiv" id="ba3CanvasDiv"><div><div class="commandCanvasTitle"> Antes: </div><div class="commandCanvasOuter"><canvas id="ba3CanvasBefore" style="width:300px;"></canvas></div></div><div style="width:50px"></div><div><div class="commandCanvasTitle"> Depois de: </div><div class="commandCanvasOuter"><canvas id="ba3CanvasAfter" style="width:300px;"></canvas></div></div></div></div><script>

        

function exampleba3() {
 var karelIde = null;
 var buttonState = 'play';
 var canvas = null;

 function main() {
    canvas = document.getElementById('ba3CanvasBefore');
    karelIde = KarelIde(null, canvas, 'stepUp', 0.0, 1000, 0.7 * 1000);

    let canvasGoal = document.getElementById('ba3CanvasAfter');
    let goalIde = KarelIde(null, canvasGoal, 'stepUpGoal',0.0,  1000, 0.7 * 1000)
 }

 
 main()
 
}
exampleba3();
    </script></div><p> Os três primeiros comandos do novo programa - os que se movem para a frente, pegam o bip e depois sobem até a borda - são os mesmos de antes: </p></p><p class="demoCode" style="margin-left:10px"><code>&nbsp;&nbsp;&nbsp;mover();</code><br/><code>&nbsp;&nbsp;&nbsp;escolherBeeper();</code><br/><code>&nbsp;&nbsp;&nbsp;mover();</code><br/></p><p> A partir daqui, o próximo passo é virar à esquerda para começar a subir a borda. Essa operação é fácil, porque Karel tem um comando vireAEsquerda em seu repertório padrão. A execução de um comando vireAEsquerda no final da sequência de comandos anterior deixa Karel voltado para o norte no canto da primeira linha e terceira coluna. Se Karel executar um comando de movimento, ele se moverá para o norte para alcançar a seguinte posição: </p>



<div class="section" id="ba3">
<div class="ide getStarted" id="ba3Ide">
<div class="commandCanvasDiv" id="ba3CanvasDiv">
<div>
<div class="commandCanvasOuter">
<canvas id="ba3Canvas" style="width:300px;"></canvas>
</div>
</div>
</div>
</div>
<script>

        

function exampleba3() {
 var karelIde = null;
 var buttonState = 'play';
 var canvas = null;

 function main() {
    canvas = document.getElementById('ba3Canvas');
    karelIde = KarelIde(null, canvas, 'stepUpM2', 0,1000, 0.7 * 1000);
 }

 
 main()
 
}
exampleba3();
    </script>
</div><p> A partir daqui, a próxima coisa que você precisa fazer é fazer com que Karel vire à direita para que fique novamente voltado para o leste. Embora esta operação seja conceitualmente tão fácil quanto fazer com que Karel vire à esquerda, há um pequeno problema: a linguagem de Karel inclui um comando <code>vireAEsquerda</code>, mas nenhum comando <code>vireÀDireita</code>. É como se você tivesse comprado o modelo econômico e descobrisse agora que está faltando algumas características importantes. </p><p> Neste ponto, você tem sua primeira oportunidade de começar a pensar como um programador. Você tem um conjunto de comandos, mas não exatamente o conjunto de que precisa. O que você pode fazer? Você consegue realizar o efeito de um comando vireÀDireita usando apenas os recursos que possui? A resposta, claro, é sim. Você pode conseguir o efeito de virar à direita, virando à esquerda três vezes. Depois de três voltas à esquerda, Karel estará enfrentando na direção desejada. A partir daqui, tudo o que você precisa fazer é programar Karel para se deslocar para o centro da borda, soltar o sinal sonoro e então avançar para a posição final. Aqui está uma implementação completa de um programa <code>PassoAcima</code> que realiza toda a tarefa: </p>



<div class="section embeddedIde" id="stepUp"><div class="ide getStarted" id="stepUpIde" style="height:422.40000000000003px"><div class="ideCenter" id="stepUpIdeCenter"><div class="ideEditorDiv" id="stepUpEditorDiv" style="width:200px"></div><div class="ideCanvasDiv" id="stepUpCanvasDiv"><canvas class="ideCanvas" id="stepUpCanvas"></canvas></div></div></div><div style="width:100%;"><div class="buttonBar"><button class="btn btn-default" id="stepUpRunButton"><span class="glyphicon glyphicon-play"></span> Rodar programa</button></div></div><script>

        

function examplestepUp() {
STARTER_CODE = `

/*
 * Ficheiro: BeeperPickingKarel.java
 * ---------------------------------
 * O programa BeeperPickingKarel define um método
 * "run" com comandos que fazem com que Karel pegue
 * um bip e coloque-o em uma borda.
 */
import stanford.karel.*;
public class BeeperPickingKarel extends Karel {
   public void run() {
      mover();
      escolherBeeper();
      mover();
      vireAEsquerda();
      mover();
      vireAEsquerda();
      vireAEsquerda();
      vireAEsquerda();
      mover();
      mover();
      colocarBeeper();
      mover();
   } 
}
`
// because of that extra endline at the start of the string
STARTER_CODE = STARTER_CODE.trim();

 var karelIde = null;
 var karelEditor = null;
 var buttonState = 'play';

 function main() {
   karelEditor = importEditorCode('stepUpEditor','stepUpEditorDiv', STARTER_CODE, false);
     //importRunButtonBar('example1ButtonBar');
    
    $("[title]").tooltip({ position: "bottom center", opacity: 0.9});
    
    initTabs();
    var canvas = document.getElementById('stepUpCanvas');
    karelIde = KarelIde(karelEditor, canvas, 'stepUp', 0.5);
    $('#stepUpRunButton').click(function(){playClicked()});
    onresize();
    
 }

 function playClicked() {
  if(buttonState == 'play') {
    karelIde.playButton();
      
      var resetText = '<span class="glyphicon glyphicon-repeat"></span> Reset Program';
      $('#stepUpRunButton').html(resetText);
      buttonState = 'reset';
     } else if (buttonState == 'reset') {
      karelIde.stopButton();
      var playText = '<span class="glyphicon glyphicon-play"></span> Run Program';
      $('#stepUpRunButton').html(playText);
      buttonState = 'play';
     }
  
  }

 function onresize() { 
    var parentHeight = 422.40000000000003;
    var canvasWidth = 300
    var parentWidth = $("#stepUp").width();
    console.log('pw: ' + parentWidth);

    var ide = document.getElementById('stepUpIde');
    var editorDiv = document.getElementById('stepUpEditorDiv');
    var canvas = document.getElementById('stepUpCanvasDiv');
    
    var ideHeight = parentHeight
    var centerHeight = ideHeight;

    var availibleWidth = parentWidth;
    var elementSpacing = 12;

    var editorWidth = availibleWidth - canvasWidth - elementSpacing; 

    canvas.style.width = canvasWidth + 'px';
    canvas.style.height = canvasWidth + 'px';
    canvas.style.left = (editorWidth + elementSpacing) + 'px';



    editorDiv.style.left = 0 + 'px'
    editorDiv.style.width = editorWidth + 'px';
    editorDiv.style.height = parentHeight + 'px';
    console.log('editor width: ' + editorWidth)

    if (karelEditor) {
       karelEditor.renderer.onResize();
    }
 }
 main()
 
}
examplestepUp();
    </script></div><hr/><center><a class="btn btn-primary btn-lg" href="chapter3.html" role="button">Próximo Capítulo</a></center>



<div style="height:60px"></div>
<!-- <div class="footer">
	<p class="pull-left">
		&#169; Stanford 2018 &#124; Made by Chris Piech. Built off "Karel the Robot Learns Java" by Eric Roberts. 
	</p>
</div>-->
<!-- <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-74362126-1', 'auto');
  ga('send', 'pageview');

</script>--></div></div></div><!-- right gutter --><div style="flex-grow:4"></div></div></div></body></html>