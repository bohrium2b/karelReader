<html><head>
<title> Leitor Karel </title><meta content="text/html; charset=utf-8" http-equiv="Content-Type"/><script src="../plugins/jquery.min.js"></script><link href="../plugins/bootstrap/css/bootstrap.min.css" rel="stylesheet"/><script src="../plugins/bootstrap/js/bootstrap.min.js"></script><link href="../style.css" rel="stylesheet"/><script src="..//karel/js/html/websiteImports.js"></script><script>importCss();</script><script>importJs();</script></head><body><!-- container --><div class="bookContainer">
<!-- side bar --><div class="bookSideBar"><div class="homeLink"><a href="http://cs106a.stanford.edu"><span aria-hidden="true" class="glyphicon glyphicon-home"></span> CS106A</a></div><hr/><div class="sideBarTitle"><a href="../pt/intro.html" style="color:black">Leitor Karel</a></div><div class="chapterTab"><a class="bookLink btn btn-link" href="../pt/chapter1.html">1 - Conheça Karel</a></div><div class="chapterTab"><a class="bookLink btn btn-link" href="../pt/chapter2.html">2 - Programação</a></div><div class="chapterTab"><a class="bookLink btn btn-link" href="../pt/chapter3.html">3 - Novos Métodos</a></div><div class="chapterTab"><a class="bookLink btn btn-link" href="../pt/chapter4.html">4 - Decomposição</a></div><div class="chapterTab"><a class="bookLink btn btn-link" href="../pt/chapter5.html">5 - For Loops</a></div><div class="chapterTab"><a class="bookLink btn btn-link" href="../pt/chapter6.html">6 - While Loops</a></div><div class="chapterTab"><a class="bookLink btn btn-link" href="../pt/chapter7.html">7 - Condicionais</a></div><div class="chapterTab"><a class="bookLink btn btn-link" href="../pt/chapter8.html">8 - Refinamento</a></div><div class="chapterTab"><a class="bookLink btn btn-link" href="../pt/chapter9.html">9 - Algoritmos</a></div><div class="chapterTab"><a class="bookLink btn btn-link" href="../pt/chapter10.html">10 - SuperKarel</a></div><!-- <center>
    <img style ="width:75px;" src="../images/stanford.png"/>
    </center>--></div><!-- content --><div class="bookContent" style="display: flex;"><!-- right gutter --><div style="flex-grow:1;max-width:50px;"></div><!-- main stuff --><div class="" style="flex-basis:740px; max-width:740px; margin-left:20px; margin-right:20px"><div class="row"><div class="col-md-12 col-xs-12">

<h1> Capítulo 4: Decomposição </h1><hr/><p> Como forma de ilustrar mais do poder que vem com a capacidade de definir novos métodos, é útil que Karel faça algo um pouco mais prático do que mover um beeper de um lugar para outro. As estradas em torno de Palo Alto, muitas vezes parecem estar precisando de reparo, e pode ser divertido ver se Karel pode preencher buracos em seu mundo abstrato. Por exemplo, imagine que Karel está de pé na “estrada” mostrada na figura da esquerda, um canto à esquerda de um buraco na estrada. O trabalho de Karel é preencher o buraco com um bip e seguir para a próxima esquina. O diagrama à direita ilustra como o mundo deve cuidar da execução do programa. </p>



<div class="section" id="ba"><div class="ide getStarted" id="baIde"><div class="commandCanvasDiv" id="baCanvasDiv"><div><div class="commandCanvasTitle"> Antes: </div><div class="commandCanvasOuter"><canvas id="baCanvasBefore" style="width:300px;"></canvas></div></div><div style="width:50px"></div><div><div class="commandCanvasTitle"> Depois de: </div><div class="commandCanvasOuter"><canvas id="baCanvasAfter" style="width:300px;"></canvas></div></div></div></div><script>

        

function exampleba() {
 var karelIde = null;
 var buttonState = 'play';
 var canvas = null;

 function main() {
    canvas = document.getElementById('baCanvasBefore');
    karelIde = KarelIde(null, canvas, 'pothole', 0.0, 1000, 0.82 * 1000);

    let canvasGoal = document.getElementById('baCanvasAfter');
    let goalIde = KarelIde(null, canvasGoal, 'potholeGoal',0.0,  1000, 0.82 * 1000)
 }

 
 main()
 
}
exampleba();
    </script></div>
<p> Se você estiver limitado aos quatro comandos predefinidos, o método de execução para resolver esse problema seria assim: </p><p style="margin-left:2em"><code><span class="keyword">private void</span> run() {</code><br/><code style="margin-left:2em">mover();</code><br/><code style="margin-left:2em">vireAEsquerda();</code><br/><code style="margin-left:2em">vireAEsquerda();</code><br/><code style="margin-left:2em">vireAEsquerda();</code><br/><code style="margin-left:2em">mover();</code><br/><code style="margin-left:2em">colocarBeeper();</code><br/><code style="margin-left:2em">vireAEsquerda();</code><br/><code style="margin-left:2em">vireAEsquerda();</code><br/><code style="margin-left:2em">mover();</code><br/><code style="margin-left:2em">vireAEsquerda();</code><br/><code style="margin-left:2em">vireAEsquerda();</code><br/><code style="margin-left:2em">vireAEsquerda();</code><br/><code style="margin-left:2em">mover();</code><br/><code>}</code></p><p> A motivação inicial para definir o método vireÀDireita era que era complicado continuar repetindo três comandos vireAEsquerda para realizar uma curva à direita. A definição de novos métodos tem outra finalidade importante além de permitir que você evite repetir as mesmas sequências de comandos sempre que quiser executar uma tarefa específica. O poder de definir métodos desbloqueia a estratégia mais importante na programação - o processo de dividir um grande problema em partes menores que são mais fáceis de resolver. O processo de decompor um programa em partes menores é chamado de decomposição, e as partes componentes de um problema grande são chamadas de subproblemas. </p><p> Como exemplo, o problema de preencher o buraco na estrada pode ser decomposto nos seguintes subproblemas: </p><ol><li> Mova-se para o buraco <li> Encha o buraco, soltando um bip nele <li> Siga para a próxima esquina </li></li></li></ol><p> Se você pensar sobre o problema dessa maneira, poderá usar as definições de método para criar um programa que reflita sua concepção da estrutura do programa. O método de execução ficaria assim: </p><p style="margin-left:2em"><code><span class="keyword">private void</span> run() {</code><br/><code style="margin-left:2em">mover();</code><br/><code style="margin-left:2em">encherOBuraco();</code><br/><code style="margin-left:2em">mover();</code><br/><code>}</code></p><p> A correspondência com o esquema é imediatamente clara, e tudo seria ótimo se você conseguisse que Karel entendesse o que você entende por encherOBuraco. Dado o poder de definir métodos, implementar o encherOBuraco é extremamente simples. Tudo o que você precisa fazer é definir um método encherOBuraco cujo corpo consista nos comandos que você já escreveu para fazer o trabalho, assim: </p><p style="margin-left:2em"><code><span class="keyword">private void</span> encherOBuraco() {</code><br/><code style="margin-left:2em">vireÀDireita();</code><br/><code style="margin-left:2em">mover();</code><br/><code style="margin-left:2em">colocarBeeper();</code><br/><code style="margin-left:2em">inversãoDeMarcha();</code><br/><code style="margin-left:2em">mover();</code><br/><code style="margin-left:2em">vireÀDireita();</code><br/><code>}</code></p><p> Aqui está o programa completo. Observe como você pode entender a intenção dos programadores simplesmente lendo o método de execução. Quando você executa o programa, o destaque da linha mostra como um computador irá executá-lo, passo a passo. No entanto, porque o programa está bem quebrado, podemos entendê-lo em um nível de pensamento humano: </p>



<div class="section embeddedIde" id="pothole"><div class="ide getStarted" id="potholeIde" style="height:686.4000000000001px"><div class="ideCenter" id="potholeIdeCenter"><div class="ideEditorDiv" id="potholeEditorDiv" style="width:200px"></div><div class="ideCanvasDiv" id="potholeCanvasDiv"><canvas class="ideCanvas" id="potholeCanvas"></canvas></div></div></div><div style="width:100%;"><div class="buttonBar"><button class="btn btn-default" id="potholeRunButton"><span class="glyphicon glyphicon-play"></span> Rodar programa</button></div></div><script>

        

function examplepothole() {
STARTER_CODE = `

import stanford.karel.*;
public class EnchimentoDeCaldeirãoKarel extends Karel {
   public void run() {
      mover();
      encherOBuraco();
      mover();
   }

   /**
    * Enche o buraco debaixo da posição atual de Karel,
    * colocando um bip naquele canto. Para que esse
    * método funcione corretamente, Karel deve estar
    * voltado para o leste imediatamente acima do
    * buraco. Quando a execução estiver completa, Karel
    * retornará ao mesmo quadrado e novamente estará
    * voltado para o leste.
    */
   private void encherOBuraco() {
      vireÀDireita();
      mover();
      colocarBeeper();
      inversãoDeMarcha();
      mover();
      vireÀDireita();
   } 

   /** Liga Karel 90 graus para a direita. */
   public void vireÀDireita() {
      vireAEsquerda();
      vireAEsquerda();
      vireAEsquerda();
   }

   /** Liga Karel em 180 graus. */
   public void inversãoDeMarcha() {
      vireAEsquerda();
      vireAEsquerda();
   }
}
`
// because of that extra endline at the start of the string
STARTER_CODE = STARTER_CODE.trim();

 var karelIde = null;
 var karelEditor = null;
 var buttonState = 'play';

 function main() {
   karelEditor = importEditorCode('potholeEditor','potholeEditorDiv', STARTER_CODE, false);
     //importRunButtonBar('example1ButtonBar');
    
    $("[title]").tooltip({ position: "bottom center", opacity: 0.9});
    
    initTabs();
    var canvas = document.getElementById('potholeCanvas');
    karelIde = KarelIde(karelEditor, canvas, 'pothole', 0.0);
    $('#potholeRunButton').click(function(){playClicked()});
    onresize();
    
 }

 function playClicked() {
  if(buttonState == 'play') {
    karelIde.playButton();
      
      var resetText = '<span class="glyphicon glyphicon-repeat"></span> Reset Program';
      $('#potholeRunButton').html(resetText);
      buttonState = 'reset';
     } else if (buttonState == 'reset') {
      karelIde.stopButton();
      var playText = '<span class="glyphicon glyphicon-play"></span> Run Program';
      $('#potholeRunButton').html(playText);
      buttonState = 'play';
     }
  
  }

 function onresize() { 
    var parentHeight = 686.4000000000001;
    var canvasWidth = 200
    var parentWidth = $("#pothole").width();
    console.log('pw: ' + parentWidth);

    var ide = document.getElementById('potholeIde');
    var editorDiv = document.getElementById('potholeEditorDiv');
    var canvas = document.getElementById('potholeCanvasDiv');
    
    var ideHeight = parentHeight
    var centerHeight = ideHeight;

    var availibleWidth = parentWidth;
    var elementSpacing = 12;

    var editorWidth = availibleWidth - canvasWidth - elementSpacing; 

    canvas.style.width = canvasWidth + 'px';
    canvas.style.height = canvasWidth + 'px';
    canvas.style.left = (editorWidth + elementSpacing) + 'px';



    editorDiv.style.left = 0 + 'px'
    editorDiv.style.width = editorWidth + 'px';
    editorDiv.style.height = parentHeight + 'px';
    console.log('editor width: ' + editorWidth)

    if (karelEditor) {
       karelEditor.renderer.onResize();
    }
 }
 main()
 
}
examplepothole();
    </script></div><hr/><center><a class="btn btn-primary btn-lg" href="chapter5.html" role="button">Próximo Capítulo</a></center>



<div style="height:60px"></div>
<!-- <div class="footer">
	<p class="pull-left">
		&#169; Stanford 2018 &#124; Made by Chris Piech. Built off "Karel the Robot Learns Java" by Eric Roberts. 
	</p>
</div>-->
<!-- <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-74362126-1', 'auto');
  ga('send', 'pageview');

</script>--></div></div></div><!-- right gutter --><div style="flex-grow:4"></div></div></div></body></html>