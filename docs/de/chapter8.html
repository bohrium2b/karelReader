<html><head>
<title> Karel Reader </title><meta content="text/html; charset=utf-8" http-equiv="Content-Type"/><script src="../plugins/jquery.min.js"></script><link href="../plugins/bootstrap/css/bootstrap.min.css" rel="stylesheet"/><script src="../plugins/bootstrap/js/bootstrap.min.js"></script><link href="../style.css" rel="stylesheet"/><script src="..//karel/js/html/websiteImports.js"></script><script>importCss();</script><script>importJs();</script></head><body><!-- container --><div class="bookContainer">
<!-- side bar -->
<div class="bookSideBar">
<div class="homeLink">
 <a href="../de/intro.html">
<span aria-hidden="true" class="glyphicon glyphicon-home"></span> Karel</a> 
</div>
<hr/>
<div class="chapterTab" onclick="location.href='../de/chapter1.html'">
<a class="bookLink btn btn-link" href="../de/chapter1.html">1 - Treffen Sie Karel</a> 
</div>
<div class="chapterTab" onclick="location.href='../de/chapter2.html'">
<a class="bookLink btn btn-link" href="../de/chapter2.html">2 - Programmierung</a> 
</div>
<div class="chapterTab" onclick="location.href='../de/chapter3.html'">
<a class="bookLink btn btn-link" href="../de/chapter3.html">3 - Neue Methoden</a> 
</div>
<div class="chapterTab" onclick="location.href='../de/chapter4.html'">
<a class="bookLink btn btn-link" href="../de/chapter4.html">4 - Zersetzung</a> 
</div>
<div class="chapterTab" onclick="location.href='../de/chapter5.html'">
<a class="bookLink btn btn-link" href="../de/chapter5.html">5 - Für Schleifen</a> 
</div>
<div class="chapterTab" onclick="location.href='../de/chapter6.html'">
<a class="bookLink btn btn-link" href="../de/chapter6.html">6 - While-Schleifen</a> 
</div>
<div class="chapterTab" onclick="location.href='../de/chapter7.html'">
<a class="bookLink btn btn-link" href="../de/chapter7.html">7 - Bedingungen</a> 
</div>
<div class="chapterTab" onclick="location.href='../de/chapter8.html'">
<a class="bookLink btn btn-link" href="../de/chapter8.html">8 - Verfeinerung</a> 
</div>
<div class="chapterTab" onclick="location.href='../de/chapter9.html'">
<a class="bookLink btn btn-link" href="../de/chapter9.html">9 - SuperKarel</a> 
</div>
<div class="chapterTab" onclick="location.href='../de/reference.html'">
<a class="bookLink btn btn-link" href="../de/reference.html">10 - Referenz</a> 
</div>
<div class="chapterTab" onclick="location.href='../de/ide.html'">
<a class="bookLink btn btn-link" href="../de/ide.html">11 - Code</a> 
</div>
<hr/>
 <a href="../"><img src="../images/unFlag.png" style="width:40px"/> Mehr erfahren</a> 
<!-- <center>
    <img style ="width:75px;" src="../images/stanford.png"/> 
    </center> -->
</div><!-- content --><div class="bookContent" style="display: flex;"><!-- right gutter --><div style="flex-grow:1;max-width:50px;"></div><!-- main stuff --><div class="" style="flex-basis:740px; max-width:740px; margin-left:20px; margin-right:20px"><div class="row"><div class="col-md-12 col-xs-12">

<h1> Kapitel 8: Schrittweise Verfeinerung </h1><hr/><p> Programmieren ist weitgehend die Wissenschaft der Problemlösung am Computer. Da Probleme häufig schwierig sind, können auch Lösungen - und die Programme, die diese Lösungen implementieren - schwierig sein. Um Ihnen die Entwicklung dieser Lösungen zu erleichtern, müssen Sie eine Methodik und eine Disziplin anwenden, die die Komplexität auf ein überschaubares Maß reduziert. </p><p> In den Anfangsjahren des Programmierens war das Konzept des Informatik als Wissenschaft mehr oder weniger ein Experiment des Wunschdenkens. Damals wusste niemand viel über das Programmieren, und nur wenige betrachteten es als technische Disziplin im herkömmlichen Sinne. Mit der Reife des Programmierens entwickelte sich jedoch eine solche Disziplin. Der Grundstein dieser Disziplin ist das Verständnis, dass das Programmieren in einem sozialen Umfeld erfolgt, in dem Programmierer zusammenarbeiten müssen. Wenn Sie in die Industrie gehen, werden Sie fast sicher einer von vielen Programmierern sein, die an der Entwicklung eines umfangreichen Programms arbeiten. Dieses Programm ist darüber hinaus fast sicher, dass es über die ursprünglich vorgesehene Anwendung hinausgeht und gewartet werden muss. Jemand möchte, dass das Programm einige neue Funktionen enthält oder auf andere Weise funktioniert. In diesem Fall muss ein neues Team von Programmierern die notwendigen Änderungen in den Programmen vornehmen. Wenn Programme in einem individuellen Stil mit wenig oder keiner Gemeinsamkeit geschrieben werden, ist es äußerst schwierig, alle dazu zu bringen, produktiv zusammenzuarbeiten. </p><p> Um dieses Problem zu bekämpfen, begannen die Programmierer, eine Reihe von Programmiermethoden zu entwickeln, die zusammen als <b>Software-Engineering bezeichnet werden</b>. Die Verwendung guter Software-Engineering-Kenntnisse erleichtert nicht nur anderen Programmierern das Lesen und Verstehen Ihrer Programme, sondern erleichtert Ihnen auch das Schreiben dieser Programme. Zu den wichtigsten methodischen Fortschritten des Software-Engineerings gehört die Strategie des <b>Top-Down-Designs</b> oder der <b>schrittweisen Verfeinerung</b>, die darin besteht, Probleme zu lösen, indem man mit dem gesamten Problem beginnt. Sie zerlegen das ganze Problem in Stücke, lösen dann jedes Stück und zerlegen es ggf. weiter. Diese Top-Down-Strategie wird durch <b>iterative Tests</b> ergänzt, bei denen Sie sicherstellen, dass die kleineren Teile der Lösung funktionieren, bevor Sie fortfahren. </p><h3> Eine Übung in schrittweiser Verfeinerung </h3><p> Um das Konzept der schrittweisen Verfeinerung zu veranschaulichen, lassen Sie uns Karel lehren, ein neues Problem zu lösen. Stellen Sie sich vor, dass Karel jetzt in einer Welt lebt, die ungefähr so aussieht: </p>




<div class="section" id="world1">
<div class="ide getStarted" id="world1Ide">
<div class="commandCanvasDiv" id="world1CanvasDiv">
<div>
<div class="commandCanvasOuter">
<canvas id="world1Canvas" style="width:400px;"></canvas>
</div>
</div>
</div>
</div>
<script>

        

function exampleworld1() {
 var karelIde = null;
 var buttonState = 'play';
 var canvas = null;

 function main() {
    canvas = document.getElementById('world1Canvas');
    karelIde = KarelIde(null, canvas, 'beeperTowers', 0,1000, 0.8 * 1000);
 }

 
 main()
 
}
exampleworld1();
    </script>
</div>
<p> Auf jeder der Säulen gibt es einen Turm von Piepsern von unbekannter Höhe, obwohl einige Säulen (wie die 7. und 9. in der Beispielwelt) leer sein könnten. Karels Aufgabe ist es, alle Piepser in jedem dieser Türme einzusammeln, an der östlichsten Ecke der ersten Reihe wieder abzusetzen und dann in die Ausgangsposition zurückzukehren. Wenn Karel seine Arbeit im obigen Beispiel beendet, sollten alle 25 Piepser, die sich derzeit in den Türmen befinden, wie folgt an der Ecke der 9. Spalte und der ersten Reihe gestapelt werden: </p>




<div class="section" id="world2">
<div class="ide getStarted" id="world2Ide">
<div class="commandCanvasDiv" id="world2CanvasDiv">
<div>
<div class="commandCanvasOuter">
<canvas id="world2Canvas" style="width:400px;"></canvas>
</div>
</div>
</div>
</div>
<script>

        

function exampleworld2() {
 var karelIde = null;
 var buttonState = 'play';
 var canvas = null;

 function main() {
    canvas = document.getElementById('world2Canvas');
    karelIde = KarelIde(null, canvas, 'beeperTowersGoal', 0,1000, 0.8 * 1000);
 }

 
 main()
 
}
exampleworld2();
    </script>
</div>
<p> Sie können davon ausgehen, dass Karel zunächst mit null Piepsern in der Tasche <i>beginnt</i>. Jeder abgeholte Piepser wird in seine Tasche aufgenommen. Wenn Sie Piepser in die Ecke stellen, kann karel den <code>piepserInDerTasche()</code>-Test verwenden. </p><p> Der Schlüssel zum Lösen dieses Problems besteht darin, das Programm auf die richtige Weise zu zerlegen und dabei trotzdem testen zu können. Diese Aufgabe ist komplexer als die anderen, die Sie gesehen haben. Daher ist die Auswahl geeigneter Teilprobleme für eine erfolgreiche Lösung wichtiger. </p><h3> Das Prinzip des Top-Down-Designs </h3><p> Die Grundidee bei der schrittweisen Verfeinerung ist, dass Sie das Design Ihres Programms von oben beginnen sollten, was sich auf die Ebene des Programms bezieht, die konzeptionell am höchsten und am abstraktesten ist. Auf dieser Ebene ist das Piepserturmproblem klar in drei unabhängige Phasen unterteilt. Zuerst muss Karel alle Piepser sammeln. Zweitens muss Karel sie an der letzten Kreuzung hinterlegen. Drittens muss Karel in seine Ausgangsposition zurückkehren. Diese konzeptionelle Zerlegung des Problems legt nahe, dass die Ausführungsmethode für dieses Programm die folgende Struktur aufweist: </p><p class="demoCode" style="margin-left:10px"><code>&nbsp;&nbsp;&nbsp;<span class="keyword">public void</span> run() {</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sammleAllePiepser();</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;allePiepserFallenLassen();</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nachHauseZurückkehren();</code><br/><code>&nbsp;&nbsp;&nbsp;}</code><br/></p><p> Auf dieser Ebene ist das Problem leicht zu verstehen. Natürlich gibt es noch einige Details in Form von Methoden, die Sie noch nicht geschrieben haben. Trotzdem ist es wichtig, auf jede Ebene der Zerlegung zu schauen und sich davon zu überzeugen, dass, solange Sie der Meinung sind, dass die Methoden, die Sie schreiben werden, die Unterprobleme richtig lösen werden, das Problem insgesamt gelöst werden kann . </p><h3> Iterative Tests, während Sie gehen </h3><p> Nachdem Sie nun die Struktur für das gesamte Programm definiert haben, ist es an der Zeit, zum ersten Teilproblem überzugehen, bei dem alle Piepser gesammelt werden. Diese Aufgabe ist an sich komplizierter als die einfachen Probleme aus den vorangegangenen Kapiteln. Wenn Sie alle Piepser sammeln, müssen Sie die Piepser in jedem Turm abholen, bis Sie die letzte Ecke erreichen. Die Tatsache, dass Sie eine Operation für jeden Turm wiederholen müssen, legt nahe, dass Sie hier eine while-Schleife benötigen. Die while-Schleife wiederholt den Vorgang von <code>sammleEinenTurm</code> und bewegt sich anschließend. </p><p><b>Achtung:</b> Es ist gefährlich, zu versuchen, das gesamte Programm zu schreiben, ohne es zu <b>testen</b>. Wenn Sie einen Fehler machen, wird es schwierig sein, den Fehler zu finden. Wir wissen, dass wir das Sammeln eines Turms wiederholen werden. Lassen Sie uns das Sammeln eines einzelnen Turms schreiben und <b>testen,</b> bevor wir den <code>SammleEinenTurm</code> Prozess in eine for-Schleife bringen. Daher können wir <i>vorübergehend</i> mit der folgenden Definition von sammleAllePiepser beginnen: <p class="demoCode" style="margin-left:10px"><code>&nbsp;&nbsp;&nbsp;<span class="keyword">private void</span> sammleAllePiepser() {</code><br/><code class="comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* temporäre Implementierung zu Testzwecken */</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sammleEinenTurm();</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bewegung();</code><br/><code>&nbsp;&nbsp;&nbsp;}</code><br/></p><p> Wenn Sie eine komplexe Schleife haben, testen Sie als Erstes den <i>Körper</i> der Schleife, bevor Sie die gesamte Schleife schreiben. </p><h3> Verfeinerung sammeln Turm </h3><p> Wenn der sammleEinenTurm gerufen wird, steht Karel entweder am Fuß eines Piepturms oder an einer leeren Ecke. Im ersten Fall müssen Sie die Piepser im Turm sammeln. Im letzteren können Sie einfach weitergehen. Diese Situation klingt wie eine Anwendung für die if-Anweisung, in der Sie Folgendes schreiben würden: </p><p class="demoCode" style="margin-left:10px"><code>&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>(piepserVorhanden()){</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tatsächlichenTurmSammeln();</code><br/><code>&nbsp;&nbsp;&nbsp;}</code><br/></p><p> Bevor Sie eine solche Anweisung zum Code hinzufügen, sollten Sie sich überlegen, ob Sie diesen Test durchführen müssen. Häufig können Programme viel einfacher gestaltet werden, indem beobachtet wird, dass Fälle, die auf den ersten Blick als besonders erscheinen, genauso behandelt werden können wie die allgemeinere Situation. Was passiert im aktuellen Problem, wenn Sie entscheiden, dass sich auf jeder Straße ein Piepserturm befindet, einige dieser Türme jedoch null Piepser hoch sind? Die Nutzung dieser Erkenntnisse vereinfacht das Programm, da Sie nicht mehr prüfen müssen, ob sich an einer bestimmten Straße ein Turm befindet. </p><p> Die Methode sammleEinenTurm ist immer noch so komplex, dass eine zusätzliche Dekomposition in Ordnung ist. Um alle Piepser in einem Turm zu sammeln, muss Karel folgende Schritte ausführen: </p><ol><li> Biegen Sie links ab, um die Piepser im Turm zu sehen. <li> Sammle alle Piepser im Turm und halte an, wenn keine weiteren Piepser gefunden werden. <li> Drehen Sie sich um, um sich dem Boden der Welt zuzuwenden. <li> Kehre zu der Wand zurück, die den Boden darstellt. <li> Biegen Sie links ab, um zur nächsten Ecke zu gelangen. </li></li></li></li></li></ol><p> Wiederum stellt diese Gliederung ein Modell für die sammleEinenTurm-Methode bereit, das wie folgt aussieht: </p><p class="demoCode" style="margin-left:10px"><code>&nbsp;&nbsp;&nbsp;<span class="keyword">private void</span> sammleEinenTurm(){</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;biegenSieLinksAb();</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;linieDerPiepserSammeln();</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;drehDichUm();</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;anDieWandGehen();</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;biegenSieLinksAb();</code><br/><code>&nbsp;&nbsp;&nbsp;}</code><br/></p><h3> Methodenvoraussetzungen und Nachbedingungen </h3><p> Die Befehle biegenSieLinksAb am Anfang und am Ende der Methode sammleEinenTurm sind beide für die Korrektheit dieses Programms entscheidend. Wenn sammleEinenTurm aufgerufen wird, ist Karel immer in der ersten Reihe in Richtung Osten. Wenn der Vorgang abgeschlossen ist, funktioniert das Programm als Ganzes nur dann korrekt, wenn Karel an derselben Ecke wieder nach Osten zeigt. Bedingungen, die erfüllt sein müssen, bevor eine Methode aufgerufen wird, werden als <b>Vorbedingungen bezeichnet</b>. Bedingungen, die nach Abschluss der Methode gelten müssen, werden als <b>Nachbedingungen bezeichnet</b>. </p><p> Wenn Sie eine Methode definieren, geraten Sie in weitaus weniger Schwierigkeiten, wenn Sie die Vor- und Nachbedingungen genau aufschreiben. Sobald Sie dies getan haben, müssen Sie sicherstellen, dass der von Ihnen geschriebene Code die Nachbedingungen immer erfüllt, vorausgesetzt, die Voraussetzungen waren von Anfang an erfüllt. Denken Sie beispielsweise darüber nach, was passiert, wenn Sie sammleEinenTurm anrufen, wenn sich Karel in der ersten Reihe nach Osten befindet. Der erste Befehl von biegenSieLinksAb lässt Karel nach Norden zeigen, was bedeutet, dass Karel richtig auf die Pultsäule ausgerichtet ist, die den Turm darstellt. Die linieDerPiepserSammeln-Methode, die noch nicht geschrieben wurde, aber eine Aufgabe ausführt, die Sie konzeptionell verstehen, bewegt sich einfach, ohne sich zu drehen. Am Ende des Aufrufs an linieDerPiepserSammeln wird Karel also weiterhin nach Norden ausgerichtet sein. Der drehDichUm-Aufruf lässt Karel also nach Süden. Wie bei linieDerPiepserSammeln beinhaltet die Methode anDieWandGehen keine Kurven, sondern bewegt sich einfach, bis sie an die Begrenzungswand stößt. Da Karel nach Süden ausgerichtet ist, befindet sich diese Begrenzungswand am unteren Rand des Bildschirms direkt unterhalb der 1. Reihe. Der letzte Befehl von biegenSieLinksAb lässt Karel daher in der ersten Reihe nach Osten, was die Nachbedingung erfüllt. </p><h3> Wiederholen Sie den Vorgang </h3><p> Sie führen Ihr Programm aus, und es löscht erfolgreich einen Turm und verlässt Karel in der versprochenen Nachbedingung. Wahoo! Sie haben gerade einen Meilenstein bei der Lösung dieser schwierigen Aufgabe erreicht! Wir müssen jetzt den Vorgang des Löschens eines Turms mit einer while-Schleife wiederholen. </p><p> Aber wie sieht diese while-Schleife aus? Zunächst sollten Sie über den Konditionstest nachdenken. Sie möchten, dass Karel anhält, wenn er am Ende der Reihe auf die Mauer trifft. Sie möchten also, dass Karel so lange weiterläuft, wie der Raum vor Ihnen frei ist. Sie wissen also, dass die sammleAllePiepser-Methode eine while-Schleife enthält, die den vorneIstKlar-Test verwendet. An jeder Position soll Karel alle Piepser im Turm abholen, die an dieser Ecke beginnen. Wenn Sie der Operation einen Namen geben, der wie sammleEinenTurm aussehen könnte, können Sie eine Definition für die sammleAllePiepser-Methode schreiben, auch wenn Sie die Details noch nicht ausgefüllt haben. </p><p> Sie müssen jedoch vorsichtig sein. Der Code für sammleAllePiepser sieht nicht so aus: </p><p class="demoCode" style="margin-left:10px"><code>&nbsp;&nbsp;&nbsp;<span class="keyword">private void</span> sammleAllePiepser(){</code><br/><code class="comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* fehlerhafte Schleife! */</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>(vorneIstKlar()) {</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sammleEinenTurm();</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bewegung();</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br/><code>&nbsp;&nbsp;&nbsp;}</code><br/></p><p> Diese Implementierung ist aus genau demselben Grund fehlerhaft, dass die erste Version der allgemeinen PlacePiepserLine aus Kapitel 6 ihre Arbeit nicht erfüllt hat. In dieser Version des Codes liegt ein Zaunpfahlfehler vor, da Karel das Vorhandensein eines Piepserturms auf der letzten Straße überprüfen muss. Die korrekte Implementierung ist: </p><p class="demoCode" style="margin-left:10px"><code>&nbsp;&nbsp;&nbsp;<span class="keyword">private void</span> sammleAllePiepser(){</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>(vorneIstKlar()) {</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sammleEinenTurm();</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bewegung();</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sammleEinenTurm();</code><br/><code>&nbsp;&nbsp;&nbsp;}</code><br/></p><p> Beachten Sie, dass diese Methode genau dieselbe Struktur wie das Hauptprogramm aus dem in Kapitel 6 vorgestellten Programm PlacePiepserLine hat. Der einzige Unterschied besteht darin, dass dieses Programm sammleEinenTurm aufruft, während das andere piepserSetzen genannt wird. Diese beiden Programme sind Beispiele für eine allgemeine Strategie, die wie folgt aussieht: </p><p class="demoCode" style="margin-left:10px"><code>&nbsp;&nbsp;&nbsp;<span class="keyword">private void</span> sammleAllePiepser(){</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>(vorneIstKlar()) {</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><i class="demoText">führt einige Operationen aus.</i><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bewegung();</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><i class="demoText">führt dieselbe Operation für die letzte Kurve aus.</i><br/><code>&nbsp;&nbsp;&nbsp;}</code><br/></p><p> Sie können diese Strategie verwenden, wenn Sie an jeder Ecke eine Operation ausführen müssen, während Sie sich entlang eines Pfads bewegen, der an einer Wand endet. Wenn Sie sich an die allgemeine Struktur dieser Strategie erinnern, können Sie sie immer dann verwenden, wenn Sie auf ein Problem stoßen, das eine solche Operation erfordert. Wieder verwendbare Strategien dieser Art kommen häufig in der Programmierung zum Einsatz und werden als <b>Programmiersprachen</b> oder <b>-muster bezeichnet</b>. Je mehr Muster Sie kennen, desto einfacher ist es, eines zu finden, das zu einem bestimmten Problem passt. </p><h3> Beenden </h3><p> Obwohl die harte Arbeit geleistet wurde, gibt es noch einige lose Enden, die gelöst werden müssen. Das Hauptprogramm ruft zwei Methoden - allePiepserFallenLassen und nachHauseZurückkehren - auf, die noch nicht geschrieben sind. Ebenso ruft sammleEinenTurm linieDerPiepserSammeln und anDieWandGehen auf. Glücklicherweise sind alle vier Methoden einfach genug, um ohne weitere Zerlegung zu codieren, insbesondere wenn Sie bei der Definition von nachHauseZurückkehren einDieWandGehen verwenden. Hier ist die vollständige Implementierung: </p>




<div class="section embeddedIde" id="beeperTowers"><div class="ide getStarted" id="beeperTowersIde" style="height:1719.9px"><div class="ideCenter" id="beeperTowersIdeCenter" style="height:inherit;"><div id="beeperTowersEditorDiv" style="width:600px;height:inherit;"></div></div></div><div id="beeperTowersCanvasDiv" style="width:500px;height:360px"><canvas class="ideCanvas" id="beeperTowersCanvas"></canvas></div><div style="width:100%;"><div class="buttonBar"><button class="btn btn-default" id="beeperTowersRunButton"><span class="glyphicon glyphicon-play"></span> Programm ausführen</button></div></div><script>

        

function examplebeeperTowers() {
STARTER_CODE = `

/*
 * Datei: ConoKarelSammeln.java
 * ---------------------------
 * Die ConoKarelSammeln-Klasse sammelt alle beeper in
 * einer Reihe vertikaler Türme und legt sie an der
 * östlichsten Ecke in der 1. Reihe ab.
 */
import stanford.karel.*;
public class ConoKarelSammeln extends Karel {

   /**
    * Gibt den Programmeinstiegspunkt an.
    */
   public void run() {
      sammleAlleConoS();
      conoAlleConoS();
      nachHauseZurückkehren();
   }

   /**
    * Sammelt die beeper s von jedem Turm, indem Sie sic
    * h entlang der ersten Reihe bewegen und an jeder Ec
    * ke sammleEinenTurm aufrufen. Nachbedingung für die
    * se Methode ist, dass sich Karel in der östlichsten
    * Ecke der 1. Reihe in Richtung Osten befindet.
    */
   private void sammleAlleConoS() {
      while (frontIsClear()) {
         sammleEinenTurm();
         move(); 
      }
      sammleEinenTurm();
   }

   /**
    * Sammelt die beeper s in einem einzigen Turm. Wenn
    * sammleEinenTurm aufgerufen wird, muss sich Karel i
    * n der ersten Reihe in Richtung Osten befinden. Die
    * Nachbedingung für sammleEinenTurm ist, dass Karel
    * an derselben Ecke wieder nach Osten blicken muss.
    */
   private void sammleEinenTurm() {
      turnLeft();
      conoVonConoS();
      turnAround();
      moveAnDieWand();
      turnLeft();
   }

   /**
    * Sammelt eine fortlaufende Zeile von beeper s. Das
    * Ende der Linie beeper wird durch eine Ecke angezei
    * gt, die keine beeper enthält.
    */
   private void conoVonConoS() {
      while (beepersPresent()) {
         pickBeeper();
         if (frontIsClear()) {
            move(); 
         }
      } 
   }

   /**
    * beeper alle beeper s in der aktuellen Ecke fallen.
    */
   private void conoAlleConoS() {
      while (beepersInBag()) {
         putBeeper();
      }
   }

   /**
    * Bringt Karel in seine Ausgangsposition an der Ecke
    * der 1st Avenue und der 1. Reihe nach Osten zurück
    * . Voraussetzung für diese Methode ist, dass Karel
    * irgendwo in der ersten Reihe nach Osten zeigt, was
    * am Ende von sammleAlleConoS zutrifft.
    */
   private void nachHauseZurückkehren() {
      turnAround();
      moveAnDieWand();
      turnAround();
   }

   /** Bewegt Karel nach vorne, bis er von einer Mauer blockiert wird. */
   private void moveAnDieWand(){
      while (frontIsClear()) {
         move();
      } 
   }

   /** Dreht Karel um 180 Grad */
   private void turnAround(){
      turnLeft();
      turnLeft();
   }
}
`
// because of that extra endline at the start of the string
STARTER_CODE = STARTER_CODE.trim();

 var karelIde = null;
 var karelEditor = null;
 var buttonState = 'play';

 function main() {
   karelEditor = importEditorCode('beeperTowersEditor','beeperTowersEditorDiv', STARTER_CODE, false);
     //importRunButtonBar('example1ButtonBar');
    
    $("[title]").tooltip({ position: "bottom center", opacity: 0.9});
    
    initTabs();
    var canvas = document.getElementById('beeperTowersCanvas');
    karelIde = KarelIde(karelEditor, canvas, 'beeperTowers', 0.9, 1000, 
      0.8 * 1000);
    $('#beeperTowersRunButton').click(function(){playClicked()});
    onresize();
 }

 function playClicked() {
  if(buttonState == 'play') {
    karelIde.playButton();
      
      var resetText = '<span class="glyphicon glyphicon-repeat"></span> Reset Program';
      $('#beeperTowersRunButton').html(resetText);
      buttonState = 'reset';
     } else if (buttonState == 'reset') {
      karelIde.stopButton();
      var playText = '<span class="glyphicon glyphicon-play"></span> Run Program';
      $('#beeperTowersRunButton').html(playText);
      buttonState = 'play';
     }
    
  }

  function onresize() { 

    // var parentHeight = 1719.9;
    // var canvasWidth = 300
    // var parentWidth = $("#beeperTowers").width();
    // console.log('pw: ' + parentWidth);

    // var editorDiv = document.getElementById('beeperTowersCanvasDiv');
    // var canvas = document.getElementById('beeperTowersCanvas');
    


    // var availibleWidth = parentWidth;
    // var elementSpacing = 12;

    // var editorWidth = availibleWidth - canvasWidth - elementSpacing; 

    // canvas.style.width = canvasWidth + 'px';
    // canvas.style.height = canvasWidth + 'px';
    // canvas.style.left = (editorWidth + elementSpacing) + 'px';
 }

 
 main()
 
}
examplebeeperTowers();
    </script></div>

</p><hr/><center><a class="btn btn-primary btn-lg" href="chapter9.html" role="button">Nächstes Kapitel</a></center>



<div style="height:60px"></div>
<!-- <div class="footer">
	<p class="pull-left">
		&#169; Stanford 2018 &#124; Made by Chris Piech. Built off "Karel the Robot Learns Java" by Eric Roberts. 
	</p>
</div>-->
<!-- <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-74362126-1', 'auto');
  ga('send', 'pageview');

</script>--></div></div></div><!-- right gutter --><div style="flex-grow:4"></div></div></div></body></html>